(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{524:function(a,t,v){"use strict";v.r(t);var _=v(10),s=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"漫谈优秀代码的十大-特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#漫谈优秀代码的十大-特性"}},[a._v("$")]),a._v(" 漫谈优秀代码的十大“特性”")]),a._v(" "),t("h2",{attrs:{id:"背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[a._v("$")]),a._v(" 背景")]),a._v(" "),t("p",[a._v("优秀的代码让人如沐春风，写好代码一定是每一位有理想程序员的毕生追求。尽管在实际工作中能够体会到优秀代码和烂代码的区别，但是大家对优秀代码似乎没有一个明确的判别标准。本文试图在笔者有限的阅历中对优秀代码的“特性”进行一下总结，以便于日后在写代码的过程中更好的提点自己。")]),a._v(" "),t("h2",{attrs:{id:"相关角色"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关角色"}},[a._v("$")]),a._v(" 相关角色")]),a._v(" "),t("p",[a._v("首先让我们来想一下代码质量通常都会对哪些角色的人产生影响，以便由此来反推优秀代码的特性。")]),a._v(" "),t("p",[a._v("对代码作者的影响无疑是最大的，他是最了解这块代码的人，他需要确保代码正确及高效运行，在出现问题的时候需要他排查，在发现 bug 的时候需要他来修复，总之他需要对代码的质量负总体责任。")]),a._v(" "),t("p",[a._v("对于其他研发人员来说，他也可能受代码质量的影响，比如需要了解代码的逻辑，甚至需要修复相关bug，代码的可读性对他来说可能更重要。")]),a._v(" "),t("p",[a._v("对于测试人员来说，他们需要对=代码中的 bug 数量负责，代码的正确性无疑是他们关注的首要因素，其次是代码能否被测试，能否尽可能避免手工测试，和高效率地被测试（包括各种单测、集成测试、性能测试）。")]),a._v(" "),t("p",[a._v("对于运维人员来说，他们更关注部署和运维的复杂度，出问题时候是否容易定位（足够的提示信息，并且不会产生误导），他们可能是低质量代码的显而易见的受害者。")]),a._v(" "),t("p",[a._v("对于最终用户来说，他们受代码正确性，性能的影响。")]),a._v(" "),t("h2",{attrs:{id:"目标特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目标特性"}},[a._v("$")]),a._v(" 目标特性")]),a._v(" "),t("p",[a._v("在有限的成本（包括时间成本）和资源情况下，尽力兼顾正确和性能是优秀代码的终极目标。为了达成此终极目标还有下文一些可实践的辅助目标。")]),a._v(" "),t("h3",{attrs:{id:"正确性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正确性"}},[a._v("$")]),a._v(" 正确性")]),a._v(" "),t("p",[a._v("正确性是写代码最基本的要求，没有正确性作为前提其他目标特性都是空谈。这个特性虽然最没有存在感，但每个合格的开发者都会默认遵守。但是要保证代码的正确性也绝非易事。")]),a._v(" "),t("h3",{attrs:{id:"高性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高性能"}},[a._v("$")]),a._v(" 高性能")]),a._v(" "),t("p",[a._v("在有限的成本和资源的前提下，人们总会追求更高的性能，而这往往需要在其他方面做出取舍。")]),a._v(" "),t("h3",{attrs:{id:"简单性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单性"}},[a._v("$")]),a._v(" 简单性")]),a._v(" "),t("p",[a._v("现实世界中万事万物的运行是没有统一准则的；但在软件开发过程中程序员的精力有限，复杂意味着更容易出现问题，简单意味着更加可靠。简单性原则直观地体现在代码量上，更一般化地体现在代码逻辑上。")]),a._v(" "),t("h3",{attrs:{id:"正交性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正交性"}},[a._v("$")]),a._v(" 正交性")]),a._v(" "),t("p",[a._v("正交性是说多个要素之间不会有交叉重叠，正交意味着更加的规则化和更少的重复，正交性与简单性是相辅相成的。")]),a._v(" "),t("h3",{attrs:{id:"可读性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可读性"}},[a._v("$")]),a._v(" 可读性")]),a._v(" "),t("p",[a._v("代码是写给人看的而不是写给机器看的，可读性高的代码会更容易维护且不容易出错。即使在某些为了性能做出妥协的情况下，高可读性也是尽可能需要达到的目标。")]),a._v(" "),t("h3",{attrs:{id:"扩展性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩展性"}},[a._v("$")]),a._v(" 扩展性")]),a._v(" "),t("p",[a._v("代码是随着时间逐步演进的，而非一成不变。基于这样的前提，在实现相同功能的前提下，扩展性越高的代码需要做出的改动越少，或者越合理，进而带来更低的时间成本和维护负担。")]),a._v(" "),t("h3",{attrs:{id:"复用性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复用性"}},[a._v("$")]),a._v(" 复用性")]),a._v(" "),t("p",[a._v("代码可以被复用意味着同样的代码能发挥更大的价值。但是可复用性并非意味着复制粘贴——恰恰相反，提高代码的复用性要尽量消除重复。相似的重复代码更容易带来隐藏的bug，更加难以维护。")]),a._v(" "),t("h3",{attrs:{id:"兼容性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#兼容性"}},[a._v("$")]),a._v(" 兼容性")]),a._v(" "),t("p",[a._v("在代码的演进过程中，数据结构和功能设计总会发生变动，优秀的代码需要在这时考虑到向前和向后的兼容（尤其是在升级和回滚的时候）而不是不负责任地把困难抛给运维人员，并期望一切顺利。")]),a._v(" "),t("h3",{attrs:{id:"可测试性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可测试性"}},[a._v("$")]),a._v(" 可测试性")]),a._v(" "),t("p",[a._v("可测试性是为实现正确性和高性能保驾护航的。写出不能被测试的代码是不负责任的，即使你能保证一次性写出来的代码没有 bug ，但你无法保证随着代码的演进不会出现退化。因此在创作之初就应该考虑到可测试性的问题，为测试工作留好足够的切入点，甚至践行“测试驱动开发”。")]),a._v(" "),t("h3",{attrs:{id:"可观测性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可观测性"}},[a._v("$")]),a._v(" 可观测性")]),a._v(" "),t("p",[a._v("可观测性是说程序在运行中的状态和指标能够被容易地观察和测量到，从而能够及时地预警问题和出现问题时方便排查。")]),a._v(" "),t("h2",{attrs:{id:"方法论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法论"}},[a._v("$")]),a._v(" 方法论")]),a._v(" "),t("p",[a._v("高内聚，低耦合")]),a._v(" "),t("p",[a._v("质能守恒定律：动手的越少，想的越多")]),a._v(" "),t("p",[a._v("关联关系：1对多。。。")]),a._v(" "),t("p",[a._v("变和不变：如何应对变化")]),a._v(" "),t("p",[a._v("两种流：读取，写入")]),a._v(" "),t("p",[a._v("注释和测试")]),a._v(" "),t("p",[a._v("分层与管道")]),a._v(" "),t("p",[a._v("约定优于配置")])])}),[],!1,null,null,null);t.default=s.exports}}]);