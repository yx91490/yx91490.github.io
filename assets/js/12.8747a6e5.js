(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{409:function(t,s,e){t.exports=e.p+"assets/img/1500016932293_3417_1500016932577.d8064a54.png"},410:function(t,s,e){t.exports=e.p+"assets/img/1500017008242_1297_1500017008596.877627af.png"},411:function(t,s,e){t.exports=e.p+"assets/img/1500017024989_2800_1500017025229.850dfae0.png"},412:function(t,s,e){t.exports=e.p+"assets/img/1500017078734_6117_1500017078936.95adf1b1.png"},413:function(t,s,e){t.exports=e.p+"assets/img/1500017105443_4641_1500017105783.7e2c42ee.png"},572:function(t,s,e){"use strict";e.r(s);var r=e(18),o=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"java-io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-io模型"}},[t._v("$")]),t._v(" Java IO模型")]),t._v(" "),s("p",[t._v("书中给出了5种IO模型：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("类型")]),t._v(" "),s("th",[t._v("英文")]),t._v(" "),s("th",[t._v("中文")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("同步")]),t._v(" "),s("td",[t._v("blocking IO")]),t._v(" "),s("td",[t._v("阻塞IO")])]),t._v(" "),s("tr",[s("td",[t._v("同步")]),t._v(" "),s("td",[t._v("nonblocking IO")]),t._v(" "),s("td",[t._v("非阻塞IO")])]),t._v(" "),s("tr",[s("td",[t._v("同步")]),t._v(" "),s("td",[t._v("IO multiplexing")]),t._v(" "),s("td",[t._v("IO多路复用")])]),t._v(" "),s("tr",[s("td",[t._v("同步")]),t._v(" "),s("td",[t._v("signal driven IO")]),t._v(" "),s("td",[t._v("信号驱动IO")])]),t._v(" "),s("tr",[s("td",[t._v("异步")]),t._v(" "),s("td",[t._v("asynchronous IO")]),t._v(" "),s("td",[t._v("异步IO")])])])]),t._v(" "),s("p",[t._v("一般情况下，一次网络IO读操作会涉及两个系统对象：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("用户进程(线程)Process；")])]),t._v(" "),s("li",[s("p",[t._v("内核对象kernel，两个处理阶段：")])])]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" Waiting "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" the data to be ready "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 等待数据准备好\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" Copying the data from the kernel to the process "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 将数据从内核空间的buffer拷贝到用户空间进程的buffer\n")])])]),s("p",[t._v("IO模型的异同点就是区分在这两个系统对象、两个处理阶段的不同上。")]),t._v(" "),s("h3",{attrs:{id:"_1-1-同步io-之-blocking-io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-同步io-之-blocking-io"}},[t._v("$")]),t._v(" 1.1 同步IO 之 Blocking IO")]),t._v(" "),s("p",[s("img",{attrs:{src:e(409),alt:"img"}})]),t._v(" "),s("p",[t._v("如上图所示，用户进程process在Blocking IO读recvfrom操作的两个阶段都是等待的。在数据没准备好的时候，process原地等待kernel准备数据。kernel准备好数据后，process继续等待kernel将数据copy到自己的buffer。在kernel完成数据的copy后process才会从recvfrom系统调用中返回。")]),t._v(" "),s("h3",{attrs:{id:"_1-2-同步io-之-nonblocking-io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-同步io-之-nonblocking-io"}},[t._v("$")]),t._v(" 1.2 同步IO 之 NonBlocking IO")]),t._v(" "),s("p",[s("img",{attrs:{src:e(410),alt:"img"}})]),t._v(" "),s("p",[t._v("从图中可以看出，process在NonBlocking IO读recvfrom操作的第一个阶段是不会block等待的，如果kernel数据还没准备好，那么recvfrom会立刻返回一个EWOULDBLOCK错误。当kernel准备好数据后，进入处理的第二阶段的时候，process会等待kernel将数据copy到自己的buffer，在kernel完成数据的copy后process才会从recvfrom系统调用中返回。")]),t._v(" "),s("h3",{attrs:{id:"_1-3-同步io-之-io-multiplexing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-同步io-之-io-multiplexing"}},[t._v("$")]),t._v(" 1.3 同步IO 之 IO multiplexing")]),t._v(" "),s("p",[s("img",{attrs:{src:e(411),alt:"img"}})]),t._v(" "),s("p",[t._v("IO多路复用，就是我们熟知的select、poll、epoll模型。从图上可见，在IO多路复用的时候，process在两个处理阶段都是block住等待的。初看好像IO多路复用没什么用，其实select、poll、epoll的优势在于可以以较少的代价来同时监听处理多个IO。")]),t._v(" "),s("h3",{attrs:{id:"_1-4-异步io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-异步io"}},[t._v("$")]),t._v(" 1.4 异步IO")]),t._v(" "),s("p",[s("img",{attrs:{src:e(412),alt:"img"}})]),t._v(" "),s("p",[t._v("从上图看出，异步IO要求process在recvfrom操作的两个处理阶段上都不能等待，也就是process调用recvfrom后立刻返回，kernel自行去准备好数据并将数据从kernel的buffer中copy到process的buffer在通知process读操作完成了，然后process在去处理。遗憾的是，linux的网络IO中是不存在异步IO的，linux的网络IO处理的第二阶段总是阻塞等待数据copy完成的。真正意义上的网络异步IO是Windows下的IOCP（IO完成端口）模型。")]),t._v(" "),s("p",[s("img",{attrs:{src:e(413),alt:"img"}})]),t._v(" "),s("p",[t._v("很多时候，我们比较容易混淆non-blocking IO和asynchronous IO，认为是一样的。但是通过上图，几种IO模型的比较，会发现non-blocking IO和asynchronous IO的区别还是很明显的，non-blocking IO仅仅要求处理的第一阶段不block即可，而asynchronous IO要求两个阶段都不能block住。")]),t._v(" "),s("blockquote",[s("p",[t._v("https://cloud.tencent.com/developer/article/1005481")])])])}),[],!1,null,null,null);s.default=o.exports}}]);