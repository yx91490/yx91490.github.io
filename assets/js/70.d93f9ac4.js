(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{490:function(e,t,a){"use strict";a.r(t);var r=a(18),n=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"cup学习笔记"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cup学习笔记"}},[e._v("$")]),e._v(" CUP学习笔记")]),e._v(" "),t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("$")]),e._v(" 简介")]),e._v(" "),t("p",[e._v("CUP是the  Java Based Constructor of Useful Parsers的简称。与YACC类似都是用来生成LALR Parser，用Java语言编写。")]),e._v(" "),t("h2",{attrs:{id:"例子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[e._v("$")]),e._v(" 例子")]),e._v(" "),t("p",[e._v("举一个用来计算整数算数表达式的例子：从标准输入读取表达式（以分号结尾），求值并输出结果到标准输出。")]),e._v(" "),t("p",[e._v("CUP 规则：")]),e._v(" "),t("div",{staticClass:"language-cup extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// CUP specification for a simple expression evaluator (w/ actions)\n\nimport java_cup.runtime.*;\n\n/* Preliminaries to set up and use the scanner.  */\ninit with {: scanner.init();              :};\nscan with {: return scanner.next_token(); :};\n\n/* Terminals (tokens returned by the scanner). */\nterminal           SEMI, PLUS, MINUS, TIMES, DIVIDE, MOD;\nterminal           UMINUS, LPAREN, RPAREN;\nterminal Integer   NUMBER;\n\n/* Non-terminals */\nnon terminal            expr_list, expr_part;\nnon terminal Integer    expr;\n\n/* Precedences */\nprecedence left PLUS, MINUS;\nprecedence left TIMES, DIVIDE, MOD;\nprecedence left UMINUS;\n\n/* The grammar */\nexpr_list ::= expr_list expr_part \n\t      | \n              expr_part;\n\nexpr_part ::= expr:e \n\t      {: System.out.println("= " + e); :} \n              SEMI              \n\t      ;\n\nexpr      ::= expr:e1 PLUS expr:e2    \n\t      {: RESULT = new Integer(e1.intValue() + e2.intValue()); :} \n\t      | \n              expr:e1 MINUS expr:e2    \n              {: RESULT = new Integer(e1.intValue() - e2.intValue()); :} \n\t      | \n              expr:e1 TIMES expr:e2 \n\t      {: RESULT = new Integer(e1.intValue() * e2.intValue()); :} \n\t      | \n              expr:e1 DIVIDE expr:e2 \n\t      {: RESULT = new Integer(e1.intValue() / e2.intValue()); :} \n\t      | \n              expr:e1 MOD expr:e2 \n\t      {: RESULT = new Integer(e1.intValue() % e2.intValue()); :} \n\t      | \n              NUMBER:n                 \n\t      {: RESULT = n; :} \n\t      | \n              MINUS expr:e             \n\t      {: RESULT = new Integer(0 - e.intValue()); :} \n\t      %prec UMINUS\n\t      | \n              LPAREN expr:e RPAREN     \n\t      {: RESULT = e; :} \n\t      ;\n')])])]),t("p",[e._v("主要包含了四个部分内容：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("第一部分引入了java_cup.runtime类，提供了一些初始化代码，以及一些用来调用scanner获取下一个输入token的代码。")])]),e._v(" "),t("li",[t("p",[e._v("第二部分声明了terminal和 non-terminal，和他们相关的class。在本例子中，terminals要么声明为无类型的，要么是Integer类型。如果没有指定类型，terminal 和 non-terminal就没有值。")])]),e._v(" "),t("li",[t("p",[e._v("第三部分声明了terminals的优先级和结合性。最后声明的terminal优先级最高。")])]),e._v(" "),t("li",[t("p",[e._v("第四部分是语法。")])])]),e._v(" "),t("p",[e._v("尽管上面的规则能构建一个完整的parser，但不会执行任何语义动作，仅仅会指示解析的成功或者失败。为了计算表达式的值，必须将java代码内置到parser中去。在CUP中，代码的字符串被"),t("code",[e._v("{:")]),e._v(" 和"),t("code",[e._v(":}")]),e._v("分隔符包围。")]),e._v(" "),t("p",[e._v("通过下面命令生成parser：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" java -jar java-cup-11b.jar parser.cup\n")])])]),t("p",[e._v("默认会生成两个文件："),t("code",[e._v("sym.java")]),e._v(" 和 "),t("code",[e._v("parser.java")]),e._v("。其中sym类包含一系列常量声明，每个terminal符号一个。")]),e._v(" "),t("p",[e._v("production：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  expr:e1 PLUS expr:e2    \n\t{: RESULT = new Integer(e1.intValue() + e2.intValue()); :} \n")])])]),t("p",[e._v("每个符号运行时都被一个Symbol对象代表。e1，e2两个label都指向了Integer对象，RESULT也声明为Integer类型。")]),e._v(" "),t("p",[e._v("对于每个label，还有其他两个变量："),t("code",[e._v("${label}left")]),e._v("和"),t("code",[e._v("${label}right")]),e._v("，分别代表了对应符号的左边和右边。")]),e._v(" "),t("p",[e._v("创建一个可行的parser的最后一步是创建scanner（或者称为"),t("em",[e._v("lexical analyzer")]),e._v(" 或简称 "),t("em",[e._v("lexer")]),e._v("）。此过程负责读入每个字符，移除空白和注释等，识别每一组字符代表的terminal符号，然后给Parser返回代表这些符号的java_cup.runtime.Symbol对象。")]),e._v(" "),t("h2",{attrs:{id:"语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[e._v("$")]),e._v(" 语法")]),e._v(" "),t("h3",{attrs:{id:"保留字"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#保留字"}},[e._v("$")]),e._v(" 保留字")]),e._v(" "),t("ul",[t("li",[e._v("action")]),e._v(" "),t("li",[e._v("code")]),e._v(" "),t("li",[e._v("import")]),e._v(" "),t("li",[e._v("init")]),e._v(" "),t("li",[e._v("left")]),e._v(" "),t("li",[e._v("non")]),e._v(" "),t("li",[e._v("nonassoc")]),e._v(" "),t("li",[e._v("nonterminal")]),e._v(" "),t("li",[e._v("package")]),e._v(" "),t("li",[e._v("parser")]),e._v(" "),t("li",[e._v("precedence")]),e._v(" "),t("li",[e._v("right")]),e._v(" "),t("li",[e._v("scan")]),e._v(" "),t("li",[e._v("start")]),e._v(" "),t("li",[e._v("terminal")]),e._v(" "),t("li",[e._v("with")])]),e._v(" "),t("h3",{attrs:{id:"package和import"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#package和import"}},[e._v("$")]),e._v(" package和import")]),e._v(" "),t("p",[e._v("可选的包声明（类似Java）：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("package name;\n")])])]),t("p",[e._v("可选的import声明：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import package_name.class_name;\nimport package_name.*;\n")])])]),t("p",[e._v("默认生成的parser类名为"),t("code",[e._v("parser")]),e._v("，符号类名为"),t("code",[e._v("sym")]),e._v("。如果定义了parser类名：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" class name;\n")])])]),t("p",[e._v("则符号类名变为"),t("code",[e._v("${parserName}Sym")]),e._v("。")]),e._v(" "),t("h3",{attrs:{id:"用户代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用户代码"}},[e._v("$")]),e._v(" 用户代码")]),e._v(" "),t("p",[e._v("action代码声明：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("action code {: ... :};\n")])])]),t("p",[e._v("parser代码声明（用来定制parser）：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("parser code {: ... :};\n")])])]),t("p",[e._v("init声明（会在parser请求token之前执行，通常用来初始化scanner和其他语义动作需要的数据结构。）：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("init with {: ... :};\n")])])]),t("p",[e._v("scan with声明：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("scan with {: ... :};\n")])])]),t("p",[e._v("返回"),t("code",[e._v("java_cup.runtime.Symbol")]),e._v("类型的对象。")]),e._v(" "),t("p",[e._v("action code, parser code, init code, 和 scan with部分可以任意顺序，但是必须在symbol 列表之前。")]),e._v(" "),t("h3",{attrs:{id:"symbol列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#symbol列表"}},[e._v("$")]),e._v(" Symbol列表")]),e._v(" "),t("p",[e._v("必选的symbol列表声明：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("terminal classname name1, name2, ...;\nnon terminal classname name1, name2, ...;\n\nterminal name1, name2, ...;\nnon terminal name1, name2, ...;\n")])])]),t("p",[t("code",[e._v("classname")]),e._v("表示"),t("code",[e._v("terminal")]),e._v("或"),t("code",[e._v("non-terminal")]),e._v("值的类型。")]),e._v(" "),t("p",[e._v("如果没有指定"),t("code",[e._v("classname")]),e._v("，则"),t("code",[e._v("terminal")]),e._v("或"),t("code",[e._v("non-terminal")]),e._v("不存储值，对应的label的值为"),t("code",[e._v("null")]),e._v("。")]),e._v(" "),t("p",[t("code",[e._v("nonterminal")]),e._v("等价于"),t("code",[e._v("non terminal")]),e._v("。")]),e._v(" "),t("h3",{attrs:{id:"优先级和结合性声明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优先级和结合性声明"}},[e._v("$")]),e._v(" 优先级和结合性声明")]),e._v(" "),t("p",[e._v("有三种类型的优先级和结合性声明：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("precedence left     terminal[, terminal...];\nprecedence right    terminal[, terminal...];\nprecedence nonassoc terminal[, terminal...];\n")])])]),t("p",[e._v("按照声明的从上到下顺序，优先级从低到高。")]),e._v(" "),t("p",[e._v("没有声明的terminal优先级最低。")]),e._v(" "),t("p",[e._v("production的优先级等同于production中最后一个terminal的优先级。如果没有terminal，则是最低优先级。")]),e._v(" "),t("p",[e._v("优先级用来解决移动（shift）和消除（reduce）冲突的问题。例如表达式："),t("code",[e._v("3 + 4 * 8")]),e._v("，是先消除"),t("code",[e._v("3+4")]),e._v(",还是移动"),t("code",[e._v("*")]),e._v("到栈上。")]),e._v(" "),t("p",[e._v("如果terminal优先级高，则将它移动到栈上。如果productoin优先级高，则消除它。如果他们优先级一样，由terminal的结合性决定决定下一步的动作。")]),e._v(" "),t("p",[e._v("如果可被shift的terminal结合性声明为left，则会执行reduce。如果结合性声明为right，则它会被shift到栈上。如果结合性声明为nonassoc，连续的同样优先级的非结合的terminal会产生报错。")]),e._v(" "),t("h3",{attrs:{id:"grammar"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#grammar"}},[e._v("$")]),e._v(" Grammar")]),e._v(" "),t("p",[e._v("可选的start with声明，指明了解析的入口：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("start with non-terminal;\n")])])]),t("p",[e._v("如果没有显式声明，则会使用第一个production的non-terminal作为入口。")]),e._v(" "),t("p",[e._v("grammar中的每个production左边是是non-terminal，接着是"),t("code",[e._v("::=")]),e._v("，一系列的action，terminal，或者non-terminal符号，上下文相关的优先级赋值，最终是一个"),t("code",[e._v("；")]),e._v("。")]),e._v(" "),t("h3",{attrs:{id:"label和location"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#label和location"}},[e._v("$")]),e._v(" Label和Location")]),e._v(" "),t("p",[e._v("terminal和non-terminal中右侧的符号可以赋一个label，label名在符号名的后面以"),t("code",[e._v(":")]),e._v("分隔。")]),e._v(" "),t("p",[e._v("label名在production中是唯一的，可以用在action code中用来引用符号的值。")]),e._v(" "),t("p",[e._v("一个non-terminal 可以由多个production组成，中间按"),t("code",[e._v("|")]),e._v("分隔。")]),e._v(" "),t("h3",{attrs:{id:"user-actions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#user-actions"}},[e._v("$")]),e._v(" User Actions")]),e._v(" "),t("p",[e._v("在"),t("code",[e._v("{:")]),e._v(" 和 "),t("code",[e._v(":}")]),e._v("中的java代码。")]),e._v(" "),t("h3",{attrs:{id:"contextual-precedence"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#contextual-precedence"}},[e._v("$")]),e._v(" Contextual precedence")]),e._v(" "),t("p",[e._v("可以给production重新赋优先级。例如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("precedence left PLUS, MINUS;\nprecedence left TIMES, DIVIDE, MOD;\nprecedence left UMINUS;\n\nexpr ::=  MINUS expr:e             \n        {: RESULT = new Integer(0 - e.intValue()); :} \n        %prec UMINUS\n")])])]),t("p",[e._v("production的优先级默认是其中最后一个terminal的优先级，而这里则声明为UMINUS的优先级。")]),e._v(" "),t("h2",{attrs:{id:"运行cup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行cup"}},[e._v("$")]),e._v(" 运行CUP")]),e._v(" "),t("h3",{attrs:{id:"命令行接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#命令行接口"}},[e._v("$")]),e._v(" 命令行接口")]),e._v(" "),t("p",[e._v("从命令行执行cup，输入规则文件，输出parser和symbol类的源码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("java -jar java-cup-11b.jar options  inputfile\n")])])]),t("p",[e._v("options：")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("option")]),e._v(" "),t("th",[e._v("默认值")]),e._v(" "),t("th",[e._v("功能")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[t("code",[e._v("-package")]),e._v(" "),t("em",[e._v("name")])]),e._v(" "),t("td",[e._v("空")]),e._v(" "),t("td",[e._v("生成的源码类的包名")])]),e._v(" "),t("tr",[t("td",[t("code",[e._v("-parser")]),e._v(" "),t("em",[e._v("name")])]),e._v(" "),t("td",[e._v("parser")]),e._v(" "),t("td",[e._v("parser和action code的源码文件名")])]),e._v(" "),t("tr",[t("td",[t("code",[e._v("-symbols")]),e._v(" "),t("em",[e._v("name")])]),e._v(" "),t("td",[e._v("sym")]),e._v(" "),t("td",[e._v("生成的符号常量类名")])]),e._v(" "),t("tr",[t("td",[e._v("-interface")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("生成符号常量为一个接口而不是类")])]),e._v(" "),t("tr",[t("td",[e._v("-nonterms")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("把non-terminals的常量也放入符号常量类中。parser不需要这些常量，但是调试一个parser的时候很有帮助。")])]),e._v(" "),t("tr",[t("td",[t("code",[e._v("-expect")]),e._v(" "),t("em",[e._v("number")])]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("为了自动解决shift/reduce或reduce/reduce冲突，由参数指定期望的冲突个数。")])]),e._v(" "),t("tr",[t("td",[e._v("-compact_red")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("启用关于reduction的table压缩优化")])]),e._v(" "),t("tr",[t("td",[e._v("-nowarn")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("禁止所有警告信息")])]),e._v(" "),t("tr",[t("td",[e._v("-nosummary")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("禁止运行后打印关于terminals, non-terminals数量，解析状态的摘要信息")])]),e._v(" "),t("tr",[t("td",[e._v("-progress")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("在parser生成过程中打印简短的信息")])]),e._v(" "),t("tr",[t("td",[e._v("-dump_grammar"),t("br"),e._v("-dump_states"),t("br"),e._v("-dump_tables"),t("br"),e._v("-dump")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("导出可读的dump信息。")])]),e._v(" "),t("tr",[t("td",[e._v("-time")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("在summary中增加详细的时间统计。")])]),e._v(" "),t("tr",[t("td",[e._v("-debug")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("在运行的时候生成冗长的中间调试信息")])]),e._v(" "),t("tr",[t("td",[e._v("-nopositions")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("如果parser没有使用到left和right的值，则省略掉运行时的计算")])]),e._v(" "),t("tr",[t("td",[e._v("-locations")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("生成xleft/xright的方法，可用于访问符号开始结束位置。")])]),e._v(" "),t("tr",[t("td",[e._v("-xmlactions")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("为所有symbol生成XMLElement-objects")])]),e._v(" "),t("tr",[t("td",[e._v("-genericlabels")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("生成完整parse tree作为XMLElement-tree")])]),e._v(" "),t("tr",[t("td",[e._v("-noscanner")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("0.10j引入了一个新接口：  "),t("code",[e._v("java_cup.runtime.Scanner")]),e._v("，此选型抑制该引用并兼容旧runtime。")])]),e._v(" "),t("tr",[t("td",[e._v("-version")]),e._v(" "),t("td"),e._v(" "),t("td",[e._v("打印版本信息")])])])]),e._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("$")]),e._v(" 参考")]),e._v(" "),t("p",[t("a",{attrs:{href:"http://www2.cs.tum.edu/projects/cup/docs.php",target:"_blank",rel:"noopener noreferrer"}},[e._v("CUP User's Manual v0.11b"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);