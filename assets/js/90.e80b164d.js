(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{489:function(t,e,r){"use strict";r.r(e);var a=r(10),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"c语言内存模型相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c语言内存模型相关"}},[t._v("$")]),t._v(" C语言内存模型相关")]),t._v(" "),e("h1",{attrs:{id:"内存模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存模型"}},[t._v("$")]),t._v(" 内存模型")]),t._v(" "),e("p",[t._v("内存中运行着很多程序，我们的程序只占用一部分空间，这部分空间又可以细分为以下的区域：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("内存分区")]),t._v(" "),e("th",[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("程序代码区(code area)")]),t._v(" "),e("td",[t._v("存放函数体的二进制代码")])]),t._v(" "),e("tr",[e("td",[t._v("静态数据区(data area)")]),t._v(" "),e("td",[t._v("也称全局数据区，包含的数据类型比较多，如全局变量、静态变量、一般常量、字符串常量。其中：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。常量数据（一般常量、字符串常量）存放在另一个区域。注意：静态数据区的内存在程序结束后由操作系统释放。")])]),t._v(" "),e("tr",[e("td",[t._v("堆区(heap area)")]),t._v(" "),e("td",[t._v("一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。malloc()、calloc()、free() 等函数操作的就是这块内存，这也是本章要讲解的重点。注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。")])]),t._v(" "),e("tr",[e("td",[t._v("栈区(stack area)")]),t._v(" "),e("td",[t._v("由系统自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。")])]),t._v(" "),e("tr",[e("td",[t._v("命令行参数区")]),t._v(" "),e("td",[t._v("存放命令行参数和环境变量的值，如通过main()函数传递的值。")])])])]),t._v(" "),e("blockquote",[e("p",[t._v("参考：永远的UNIX 高质量C++-C编程指南 – 第7章 内存管理 (1)")])]),t._v(" "),e("h4",{attrs:{id:"_7-4指针参数是如何传递内存的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-4指针参数是如何传递内存的"}},[t._v("$")]),t._v(" 7.4指针参数是如何传递内存的？")]),t._v(" "),e("p",[t._v("如果函数的参数是一个指针，不要指望用该指针去申请动态内存。示例7-4-1中，Test函数\n的语句GetMemory(str, 200)并没有使str获得期望的内存，str依旧是NULL，为什么？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('void GetMemory(char *p, int num)\n{\n    p = (char *)malloc(sizeof(char) * num);\n}\nvoid Test(void)\n{\n    char *str = NULL;\n    GetMemory(str, 100);    // str 仍然为 NULL\n    strcpy(str, "hello");   // 运行错误\n}\n')])])]),e("p",[e("strong",[t._v("示例7-4-1 试图用指针参数申请动态内存")])]),t._v(" "),e("p",[t._v("毛病出在函数GetMemory中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 _p，编译器使 _p =p。如果函数体内的程序修改了_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p申请了新的内存，只是把_p所指的内存地址改变了，但是p丝毫未变。所以函数GetMemory并不能输出任何东西。事实上，每执行一次GetMemory就会泄露一块内存，因为没有用free释放内存。\n如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”，见示例7-4-2。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('void GetMemory2(char **p, int num)\n{\n    *p = (char *)malloc(sizeof(char) * num);\n}\nvoid Test2(void)\n{\n    char *str = NULL;\n    GetMemory2(&str, 100); // 注意参数是 &str，而不是str\n    strcpy(str, "hello");  \n    cout<< str << endl;\n    free(str);\n}\n')])])]),e("p",[e("strong",[t._v("示例7-4-2用指向指针的指针申请动态内存")])]),t._v(" "),e("p",[t._v("由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单，见示例7-4-3。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('char *GetMemory3(int num)\n{\n    char *p = (char *)malloc(sizeof(char) * num);\n    return p;\n}\nvoid Test3(void)\n{\n    char *str = NULL;\n    str = GetMemory3(100);\n    strcpy(str, "hello");\n    cout<< str << endl;\n    free(str);\n}\n')])])]),e("p",[e("strong",[t._v("示例7-4-3 用函数返回值来传递动态内存")])]),t._v(" "),e("p",[t._v("用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡，见示例7-4-4。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('char *GetString(void)\n{\n    char p[] = "hello world";\n    return p;   // 编译器将提出警告\n}\nvoid Test4(void)\n{\nchar *str = NULL;\nstr = GetString(); // str 的内容是垃圾\ncout<< str << endl;\n}\n')])])]),e("p",[e("strong",[t._v("示例7-4-4 return语句返回指向“栈内存”的指针")])]),t._v(" "),e("p",[t._v("用调试器逐步跟踪Test4，发现执行str = GetString语句后str不再是NULL指针，但是str的内容不是“hello world”而是垃圾。\n如果把示例7-4-4改写成示例7-4-5，会怎么样？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('char *GetString2(void)\n{\n    char *p = "hello world";\n    return p;\n}\nvoid Test5(void)\n{\n    char *str = NULL;\n    str = GetString2();\n    cout<< str << endl;\n}\n')])])]),e("p",[e("strong",[t._v("示例7-4-5 return语句返回常量字符串")])]),t._v(" "),e("p",[t._v("函数Test5运行虽然不会出错，但是函数GetString2的设计概念却是错误的。因为GetString2内的“hello world”是常量字符串，位于静态存储区，它在程序生命期内恒定不变。无论什么时候调用GetString2，它返回的始终是同一个“只读”的内存块。\n14.函数参数的传递分为：值传送和引用（指针）传送。前者将变量的复本传给函数的形参，形参的改变不会引起变量原值得改变；后者将变量的地址传给形参，形参的改变将引起变量的改变。")]),t._v(" "),e("h1",{attrs:{id:"extern"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#extern"}},[t._v("$")]),t._v(" extern")]),t._v(" "),e("p",[t._v("注意：未初始化的全局变量的默认值是 0，而未初始化的局部变量的值却是垃圾值（任意值）。\n在所有的代码块（函数、if 块、switch 块等）之外定义的变量称为全局变量，它的作用范围默认是整个程序，也就是所有的源文件，包括 .c 和 .h 文件。\n如果你一直在编写单个 .c 文件的程序，那么请注意，全局变量的作用范围不是从变量定义处到该文件结束，在其他文件中也有效。\n虽然全局变量的作用范围是整个程序，但是如果希望在 a.c 中使用 b.c 中的变量，也必须先进行声明。声明使用 extern 关键字，"),e("strong",[t._v("与其他变量不同，extern 变量有声明和定义之分")]),t._v("。\nextern 变量的定义格式为：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("extern type name = value;\n")])])]),e("p",[t._v("不过 extern 可以省略（我们通常就是这么做的），全局变量默认就是 extern 的.\n声明格式为：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("extern type name;\n")])])]),e("p",[t._v("注意：")]),t._v(" "),e("ul",[e("li",[t._v("在定义 extern 变量时不能省略 value，否则就变成了变量声明。")]),t._v(" "),e("li",[t._v("声明 extern 变量时要指明数据类型（必须和定义时的数据类型一致）。")]),t._v(" "),e("li",[t._v("声明可以有多次，定义只能有一次。")])]),t._v(" "),e("p",[t._v("但是，函数和变量的声明有所不同，对于函数，你可以省略 extern。这是因为，函数的定义和声明区别很明显，有函数体就是定义，没有函数体就是声明，所以有没有 extern 都是函数声明。但是变量不一样，没有 extern 就是变量定义，重复定义是错误的。")]),t._v(" "),e("h1",{attrs:{id:"static"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#static"}},[t._v("$")]),t._v(" static")]),t._v(" "),e("p",[t._v("static 声明的变量称为静态变量，不管是全局变量还是局部变量，都存储在静态数据区（全局变量本来就存储在静态数据区，即使不加 static）。\n静态数据区的数据在程序启动时就会初始化，直到程序运行结束；对于代码块中的静态局部变量，即使代码块执行结束，也不会销毁。\n注意：静态数据区的变量只能初始化（定义）一次，以后只能改变它的值，不能再被初始化，即使有这样的语句，也无效。\n总结起来，static 变量的主要作用有两个：\n\\1. 程序有多个源文件时，将全局变量或函数的作用范围限制在当前文件，对其他文件隐藏。\n\\2. 保持变量内容的持久化将局部变量存储到静态数据区。静态数据区的内存在程序启动时就已分配好（内存中所有的字节默认值都是0x00），直到程序运行结束。")])])}),[],!1,null,null,null);e.default=n.exports}}]);