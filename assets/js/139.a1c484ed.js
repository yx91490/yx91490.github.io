(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{534:function(t,e,l){"use strict";l.r(e);var _=l(10),i=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_3种让线程等待和唤醒的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3种让线程等待和唤醒的方法"}},[t._v("$")]),t._v(" 3种让线程等待和唤醒的方法")]),t._v(" "),e("p",[t._v("3种让线程等待/唤醒的方法：")]),t._v(" "),e("ol",[e("li",[t._v("使用Object中的"),e("code",[t._v("wait()")]),t._v("方法让线程等待，使用Object中的notify()方法唤醒线程")]),t._v(" "),e("li",[t._v("使用juc包中Condition的await()方法让线程等待，使用signal()方法唤醒线程")]),t._v(" "),e("li",[t._v("使用LockSupport的park()系列方法阻塞当前线程，使用unpark方法或者调用等待线程的 interrupt()方法唤醒线程")])]),t._v(" "),e("p",[t._v("3种方式对比：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}}),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("Object")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("Condtion")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("LockSupport")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("前置条件")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("需要在synchronized中运行")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("需要先获取Lock的锁")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("无")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("无限等待")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("支持")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("超时等待")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("支持")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("等待到将来某个时间返回")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("不支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("支持")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("等待状态中释放锁?")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("会释放")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("会释放")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("不会释放")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("唤醒方法先于等待方法执行，能否唤醒线程")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("否")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("否")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("可以")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("是否能响应线程中断")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("是")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("是")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("是")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("线程中断是否会清除中断标志?")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("是")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("是")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("否")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("是否支持等待状态中不响应中断?")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("不支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("不支持")])])])]),t._v(" "),e("p",[t._v("关于Object类中的用户线程等待和唤醒的方法，总结一下：")]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("wait(), notify(), notifyAll()")]),t._v("方法都必须放在同步代码中执行，需要先获取锁")])]),t._v(" "),e("li",[e("p",[t._v("线程唤醒的方法"),e("code",[t._v("notify(), notifyAll()")]),t._v("需要在等待的方法"),e("code",[t._v("wait")]),t._v("之后执行，等待中的线程才可能会被唤醒，否则无法唤醒")])])]),t._v(" "),e("p",[t._v("关于Condition中方法使用总结：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("使用Condition中的线程等待和唤醒方法之前，需要先获取锁")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("signal()")]),t._v("方法先于"),e("code",[t._v("await()")]),t._v("方法之前调用，线程无法被唤醒")])])]),t._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("$")]),t._v(" 参考")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:""}},[t._v("java高并发系列 - 第14天:JUC中的LockSupport工具类，必备技能")])])])])}),[],!1,null,null,null);e.default=i.exports}}]);