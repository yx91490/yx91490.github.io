(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{575:function(a,t,v){"use strict";v.r(t);var _=v(10),s=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"漫谈优秀代码的十大-特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#漫谈优秀代码的十大-特性"}},[a._v("$")]),a._v(" 漫谈优秀代码的十大“特性”")]),a._v(" "),t("h2",{attrs:{id:"背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[a._v("$")]),a._v(" 背景")]),a._v(" "),t("p",[a._v("写好代码一定是一位有理想程序员的毕生追求，优秀的代码确实会让人感觉如沐春风。虽然工作中能体会到什么是烂代码什么是优秀代码，但是对优秀代码似乎没有一个明确的判别标准。本文试图在笔者有限的阅历中对优秀代码的“特性”进行一下总结，以便于日后在写代码的时候更好的提点自己。")]),a._v(" "),t("h2",{attrs:{id:"相关角色"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关角色"}},[a._v("$")]),a._v(" 相关角色")]),a._v(" "),t("p",[a._v("首先让我们来思考一下理想情况下代码质量都会对哪些角色产生影响。")]),a._v(" "),t("p",[a._v("对于代码的作者来说无疑影响是最大的，他是最了解这块代码的人，他需要尽力确保代码正确及高效运行，在出现问题的时候需要他排查，在发现 bug 的时候需要他来修复，总之他需要对代码的质量负总体责任。")]),a._v(" "),t("p",[a._v("对于其他研发人员来说，他也可能受代码质量的影响，比如需要了解代码的逻辑，甚至需要修复相关bug，代码的可读性对他来说可能更重要。")]),a._v(" "),t("p",[a._v("对于测试人员来说，他们需要对=代码中的 bug 数量负责，代码的正确性无疑是他们关注的首要因素，其次是代码能否被测试，能否尽可能避免手工测试，和高效率地被测试（包括各种单测、集成测试、性能测试）。")]),a._v(" "),t("p",[a._v("对于运维人员来说，他们更关注部署和运维的复杂度，出问题时候是否容易定位（足够的提示信息，并且不会产生误导），他们可能是低质量代码的显而易见的受害者。")]),a._v(" "),t("p",[a._v("对于最终客户来说，他们受代码正确性，性能的影响。")]),a._v(" "),t("h2",{attrs:{id:"目标特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目标特性"}},[a._v("$")]),a._v(" 目标特性")]),a._v(" "),t("p",[a._v("我认为在有限的成本（包括时间成本）和资源情况下，尽可能做到正确和高性能是优秀代码的终极目标。为了达成此此终极目标还有下文一些可实践的辅助目标。")]),a._v(" "),t("h3",{attrs:{id:"正确性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正确性"}},[a._v("$")]),a._v(" 正确性")]),a._v(" "),t("p",[a._v("正确性是写代码最基本的要求，没有正确性作为前提其他目标特性都是空谈。这个特性虽然最没有存在感，但每个合格的开发者都会默认遵守。但是要保证代码的正确性也绝非易事。")]),a._v(" "),t("h3",{attrs:{id:"高性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高性能"}},[a._v("$")]),a._v(" 高性能")]),a._v(" "),t("p",[a._v("在有限的成本和资源的前提下，人们总会追求更高的性能，而这往往需要在某些方面做出取舍。")]),a._v(" "),t("h3",{attrs:{id:"简单性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单性"}},[a._v("$")]),a._v(" 简单性")]),a._v(" "),t("p",[a._v("现实世界中万事万物是百花齐放没有统一准则的，但是在软件开发过程中程序员的精力有限，复杂意味着更容易出现问题，简单意味着更加可靠。简单性原则直观地体现在代码量上，更一般化地体现在代码逻辑上。")]),a._v(" "),t("h3",{attrs:{id:"正交性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正交性"}},[a._v("$")]),a._v(" 正交性")]),a._v(" "),t("p",[a._v("正交是说多个要素之间不会有交叉重叠，正交意味着更加的规则化和更少的重复，正交性与简单性是相辅相成的。")]),a._v(" "),t("h3",{attrs:{id:"可读性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可读性"}},[a._v("$")]),a._v(" 可读性")]),a._v(" "),t("p",[a._v("代码是写给人看的而不是写给机器看的，良好的可读性会更容易维护和不容易出错。即使在为性能做出妥协的极端情况下，高可读性也是需要尽可能达到的目标。")]),a._v(" "),t("h3",{attrs:{id:"扩展性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩展性"}},[a._v("$")]),a._v(" 扩展性")]),a._v(" "),t("p",[a._v("代码不是一成不变的，代码是随着时间逐步演进的。基于这样的前提，扩展性越高的代码，在实现相同的功能情况下需要对代码做出的改动越少，或者改动更合理。进而会带来更低的时间成本和维护负担。")]),a._v(" "),t("h3",{attrs:{id:"复用性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复用性"}},[a._v("$")]),a._v(" 复用性")]),a._v(" "),t("p",[a._v("代码可以被复用意味着同样的代码能发挥更大的价值。但是可复用性并非意味着复制粘贴——恰恰相反，提高代码的复用性要尽量消除重复，相似的重复代码更容易带来隐藏的bug，更加难以维护。")]),a._v(" "),t("h3",{attrs:{id:"兼容性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#兼容性"}},[a._v("$")]),a._v(" 兼容性")]),a._v(" "),t("p",[a._v("现实情况下，在代码的演进过程中，数据结构和功能设计总会发生变动，优秀的代码需要在这时考虑到向前和向后的兼容，尤其是在升级和回滚的时候，而不是不负责任地把困难抛给运维人员，期望一切顺利。")]),a._v(" "),t("h3",{attrs:{id:"可测试性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可测试性"}},[a._v("$")]),a._v(" 可测试性")]),a._v(" "),t("p",[a._v("可测试性是为实现正确性和高性能保驾护航的。写出不能被测试的代码是不负责任的，即使你能保证一次性写出来的代码没有 bug ，但你无法保证随着代码的演进不会出现退化现象。因此在创作之初就应该考虑到可测试性的问题，为测试工作留好足够的切入点，甚至践行“测试驱动开发”。")]),a._v(" "),t("h3",{attrs:{id:"可观测性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可观测性"}},[a._v("$")]),a._v(" 可观测性")]),a._v(" "),t("p",[a._v("可观测性是说在程序运行过程中的状态和指标能够被容易地观察和测量到，从而能够及时地预警和方便排查问题。")]),a._v(" "),t("h2",{attrs:{id:"方法论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法论"}},[a._v("$")]),a._v(" 方法论")]),a._v(" "),t("p",[a._v("高内聚，低耦合")]),a._v(" "),t("p",[a._v("质能守恒定律：动手的越少，想的越多")]),a._v(" "),t("p",[a._v("关联关系：1对多。。。")]),a._v(" "),t("p",[a._v("变和不变：如何应对变化")]),a._v(" "),t("p",[a._v("两种流：读取，写入")]),a._v(" "),t("p",[a._v("注释和测试")]),a._v(" "),t("p",[a._v("分层与管道")]),a._v(" "),t("p",[a._v("约定优于配置")])])}),[],!1,null,null,null);t.default=s.exports}}]);