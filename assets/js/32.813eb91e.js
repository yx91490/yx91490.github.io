(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{285:function(a,e,r){a.exports=r.p+"assets/img/The_YARN_architecture_iteblog.64a18f5d.jpg"},445:function(a,e,r){"use strict";r.r(e);var t=r(10),n=Object(t.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"yarn"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#yarn"}},[a._v("$")]),a._v(" Yarn")]),a._v(" "),e("h2",{attrs:{id:"架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#架构"}},[a._v("$")]),a._v(" 架构")]),a._v(" "),e("h4",{attrs:{id:"resourcemanager"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#resourcemanager"}},[a._v("$")]),a._v(" ResourceManager")]),a._v(" "),e("p",[a._v("每个Hadoop集群只会有一个ResourceManager（如果是HA的话会存在两个，但是有且只有一个处于active状态），它负责管理整个集群的计算资源，并将这些资源分别给应用程序。ResourceManager 内部主要有两个组件：")]),a._v(" "),e("ul",[e("li",[a._v("Scheduler:这个组件完全是插拔式的，用户可以根据自己的需求实现不同的调度器，目前YARN提供了FIFO、容量以及公平调度器。这个组件的唯一功能就是给提交到集群的应用程序分配资源，并且对可用的资源和运行的队列进行限制。Scheduler并不对作业进行监控；")]),a._v(" "),e("li",[a._v("ApplicationsManager (AsM):这个组件用于管理整个集群应用程序的application masters，负责接收应用程序的提交；为application master启动提供资源；监控应用程序的运行进度以及在应用程序出现故障时重启它。")])]),a._v(" "),e("h4",{attrs:{id:"nodemanager"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nodemanager"}},[a._v("$")]),a._v(" NodeManager")]),a._v(" "),e("p",[a._v("NodeManager是YARN中每个节点上的代理，它管理Hadoop集群中单个计算节点，根据相关的设置来启动容器的。NodeManager会定期向ResourceManager发送心跳信息来更新其健康状态。同时其也会监督Container的生命周期管理，监控每个Container的资源使用（内存、CPU等）情况，追踪节点健康状况，管理日志和不同应用程序用到的附属服务（auxiliary service）。")]),a._v(" "),e("h4",{attrs:{id:"applicationmaster"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#applicationmaster"}},[a._v("$")]),a._v(" ApplicationMaster")]),a._v(" "),e("p",[a._v("ApplicationMaster是应用程序级别的，每个ApplicationMaster管理运行在YARN上的应用程序。YARN 将 ApplicationMaster看做是第三方组件，ApplicationMaster负责和ResourceManager scheduler协商资源，并且和NodeManager通信来运行相应的task。ResourceManager 为 ApplicationMaster 分配容器，这些容器将会用来运行task。ApplicationMaster 也会追踪应用程序的状态，监控容器的运行进度。当容器运行完成， ApplicationMaster 将会向 ResourceManager 注销这个容器；如果是整个作业运行完成，其也会向 ResourceManager 注销自己，这样这些资源就可以分配给其他的应用程序使用了。")]),a._v(" "),e("h4",{attrs:{id:"container"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#container"}},[a._v("$")]),a._v(" Container")]),a._v(" "),e("p",[a._v("Container是与特定节点绑定的，其包含了内存、CPU磁盘等逻辑资源。不过在现在的容器实现中，这些资源只包括了内存和CPU。容器是由 ResourceManager scheduler 服务动态分配的资源构成。容器授予 ApplicationMaster 使用特定主机的特定数量资源的权限。ApplicationMaster 也是在容器中运行的，其在应用程序分配的第一个容器中运行。")]),a._v(" "),e("p",[a._v("作业的完整运行如下所示：")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://www.iteblog.com/pic/hadoop/The_YARN_architecture_iteblog.jpg",target:"_blank",rel:"noopener noreferrer"}},[e("img",{attrs:{src:r(285),alt:"The YARN architecture"}}),e("OutboundLink")],1)]),a._v(" "),e("h2",{attrs:{id:"配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置"}},[a._v("$")]),a._v(" 配置")]),a._v(" "),e("table",[e("thead",[e("tr",[e("th",[a._v("配置项")]),a._v(" "),e("th",[a._v("备注")])])]),a._v(" "),e("tbody",[e("tr",[e("td",[a._v("yarn.log-aggregation-enable")]),a._v(" "),e("td",[a._v("是否启用日志聚合")])]),a._v(" "),e("tr",[e("td",[a._v("yarn.nodemanager.remote-app-log-dir")]),a._v(" "),e("td",[a._v("日志聚合目录")])]),a._v(" "),e("tr",[e("td",[a._v("yarn.nodemanager.remote-app-log-dir-suffix")]),a._v(" "),e("td",[a._v("将在{yarn.nodemanager.remote-app-log-dir} / $ {user} / {thisParam}中创建远程日志目录。默认值为“ logs”")])]),a._v(" "),e("tr",[e("td",[a._v("yarn.nodemanager.log-dirs")]),a._v(" "),e("td",[a._v("container本地化日志目录路径："),e("code",[a._v("${yarn.nodemanager.log-dirs}/application_${appid}")])])]),a._v(" "),e("tr",[e("td",[a._v("yarn.log-aggregation.retain-seconds")]),a._v(" "),e("td",[a._v("删除聚合日志前要等待多长时间")])]),a._v(" "),e("tr",[e("td",[a._v("yarn.log.server.url")]),a._v(" "),e("td")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);