(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{483:function(_,e,v){"use strict";v.r(e);var t=v(10),l=Object(t.a)({},(function(){var _=this,e=_._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"zookeeper实现分布式锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper实现分布式锁"}},[_._v("$")]),_._v(" zookeeper实现分布式锁")]),_._v(" "),e("h4",{attrs:{id:"锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[_._v("$")]),_._v(" 锁")]),_._v(" "),e("p",[_._v("完全分布式的锁是全局同步的，意味着任何时刻不会有两个客户端认为他们持有同一把锁，这可以用zookeeper来实现，首先定义一个锁节点。")]),_._v(" "),e("p",[_._v("client加锁的操作如下：")]),_._v(" "),e("ol",[e("li",[_._v("调用 "),e("strong",[_._v("create( )")]),_._v(" 方法创建一个路径名为"),e("code",[_._v("_locknode_/lock-")]),_._v("的临时有序节点路径。")]),_._v(" "),e("li",[_._v("在锁节点上调用**getChildren( )**方法（不要watch该节点以避免惊群效应）。")]),_._v(" "),e("li",[_._v("如果第1步中创建的路径后缀序号是最小的，则client获得了锁并退出后续的协议。")]),_._v(" "),e("li",[_._v("client在锁目录下比自己序号小一个的路径上调用**exists( )**方法并设置watch标志。")]),_._v(" "),e("li",[_._v("如果**exists( )**返回"),e("code",[_._v("false")]),_._v("，回到第2步；否则等待第4步中设置的通知然后返回第2步。")])]),_._v(" "),e("p",[_._v("client释放锁的协议很简单：只要把第1步中创建的节点删除即可。")]),_._v(" "),e("p",[_._v("需要注意的几点：")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("移除一个节点只会唤醒一个client，因为每个节点只被一个clientwatch，这样就避免了惊群效应。")])]),_._v(" "),e("li",[e("p",[_._v("不会有轮询或者超时的操作。")])]),_._v(" "),e("li",[e("p",[_._v("由这种实现锁的方式很容易实现查看锁竞争的数量，移除锁，debug锁情况等。")])])]),_._v(" "),e("h4",{attrs:{id:"共享锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#共享锁"}},[_._v("$")]),_._v(" 共享锁")]),_._v(" "),e("p",[_._v("进行一些调整就可以实现共享锁：")]),_._v(" "),e("p",[_._v("获取读锁：")]),_._v(" "),e("ol",[e("li",[_._v("调用 "),e("strong",[_._v("create( )")]),_._v(" 方法创建一个路径名为"),e("code",[_._v("_locknode_/read-")]),_._v("的临时有序节点路径。")]),_._v(" "),e("li",[_._v("在锁节点上调用**getChildren( )**方法（不要watch该节点以避免惊群效应）。")]),_._v(" "),e("li",[_._v("如果没有子节点的路径名以"),e("code",[_._v("write-")]),_._v("开头并且序号是第1步中创建节点的下一个，则client获得了锁并退出后续的协议。")]),_._v(" "),e("li",[_._v("对锁目录中路径名以"),e("code",[_._v("write-")]),_._v("开头并且序号是下一个的节点调用**exists( )**方法并设置watch标志。")]),_._v(" "),e("li",[_._v("如果**exists( )**返回"),e("code",[_._v("false")]),_._v("，回到第2步；否则等待第4步中设置的通知然后返回第2步。")])]),_._v(" "),e("p",[_._v("获取写锁：")]),_._v(" "),e("ol",[e("li",[_._v("调用 "),e("strong",[_._v("create( )")]),_._v(" 方法创建一个路径名为"),e("code",[_._v("_locknode_/write-")]),_._v("的临时有序节点路径。")]),_._v(" "),e("li",[_._v("在锁节点上调用**getChildren( )**方法（不要watch该节点以避免惊群效应）。")]),_._v(" "),e("li",[_._v("如果第1步中创建的路径后缀序号是最小的，则client获得了锁并退出后续的协议。")]),_._v(" "),e("li",[_._v("client在锁目录下比自己序号小一个的路径上调用**exists( )**方法并设置watch标志。")]),_._v(" "),e("li",[_._v("如果**exists( )**返回"),e("code",[_._v("false")]),_._v("，回到第2步；否则等待第4步中设置的通知然后返回第2步。")])]),_._v(" "),e("p",[_._v("这似乎显得这个方案创建了一个惊群效应：当序号最小的写节点被删除的时候，所有等待获取读锁的client都会感知到。事实上这是有效的行为：所有等待读的client都应该被释放因为他们获取到锁了。惊群效应指的是只有一个或少部分的机器会处理却触发整个集群。")]),_._v(" "),e("p",[_._v("参考：")]),_._v(" "),e("blockquote",[e("p",[_._v("http://zookeeper.apache.org/doc/r3.4.9/recipes.html")]),_._v(" "),e("p",[_._v("http://www.importnew.com/27019.html")]),_._v(" "),e("p",[_._v("https://colobu.com/2014/12/12/zookeeper-recipes-by-example-2")])])])}),[],!1,null,null,null);e.default=l.exports}}]);