(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{438:function(a,e,r){"use strict";r.r(e);var t=r(10),o=Object(t.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"datax源码学习笔记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#datax源码学习笔记"}},[a._v("$")]),a._v(" DataX源码学习笔记")]),a._v(" "),e("h2",{attrs:{id:"主流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主流程"}},[a._v("$")]),a._v(" 主流程")]),a._v(" "),e("p",[a._v("DataX的启动脚本是"),e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/bin/datax.py",target:"_blank",rel:"noopener noreferrer"}},[a._v("bin/datax.py"),e("OutboundLink")],1),a._v("，主要负责拼接类一些启动参数，然后启动JVM进程，JVM进程的入口类是"),e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/Engine.java",target:"_blank",rel:"noopener noreferrer"}},[a._v("com.alibaba.datax.core.Engine.java"),e("OutboundLink")],1),a._v("，从入口类开始的数据流程如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Engine.main()\n└── Engine.entry()\n    └── Engine.start()\n        └── JobContainer.start()\n            ├── JobContainer.preHandle()         // 加载PreHandler插件的preHandler()接口\n            ├── JobContainer.init()              // 加载Reader和Writer插件对应的init()接口\n            │   ├── JobContainer.initJobReader()\n            │   └── JobContainer.initJobWriter()\n            ├── JobContainer.prepare()           // 加载Reader和Writer插件对应的prepare()接口\n            │   ├── JobContainer.prepareJobReader()\n            │   └── JobContainer.prepareJobWriter()\n            ├── JobContainer.split()\n            ├── JobContainer.schedule()          // 调度执行\n            ├── JobContainer.post()              // 加载Reader和Writer插件对应的post()接口\n            │   ├── JobContainer.postJobWriter()\n            │   └── JobContainer.postJobReader()\n            ├── JobContainer.postHandle()        // 加载PostHandler插件的postHandler()接口\n            └── JobContainer.invokeHooks()       // 调用外部hook\n")])])]),e("h3",{attrs:{id:"jobcontainer-prehandle-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jobcontainer-prehandle-方法"}},[a._v("$")]),a._v(" JobContainer.preHandle()方法")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/job/JobContainer.java#L312",target:"_blank",rel:"noopener noreferrer"}},[a._v("JobContainer.preHandle()方法"),e("OutboundLink")],1),a._v("根据配置里面的"),e("code",[a._v("job.preHandler.pluginType")]),a._v("和"),e("code",[a._v("job.preHandler.pluginName")]),a._v("获取到Handler的类型和名称，然后调用自定义的ClassLoader加载对应的类，并调用preHandler()接口。")]),a._v(" "),e("h3",{attrs:{id:"jobcontainer-init-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jobcontainer-init-方法"}},[a._v("$")]),a._v(" JobContainer.init()方法")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/job/JobContainer.java#L287",target:"_blank",rel:"noopener noreferrer"}},[a._v("JobContainer.init()方法"),e("OutboundLink")],1),a._v("首先会初始化JobId（JobId在Standalone模式下没有意义），然后设置线程名。")]),a._v(" "),e("p",[a._v("根据配置里面的"),e("code",[a._v("job.content[0].reader.name")]),a._v("获取Reader插件的插件名，根据配置里面的"),e("code",[a._v("job.content[0].reader.parameter")]),a._v("获取Reader插件的jobConf，根据配置里面的"),e("code",[a._v("job.content[0].writer.parameter")]),a._v("获取Writer插件的jobConf，最后调用Reader插件的init()接口。")]),a._v(" "),e("p",[a._v("同样的Writer插件也是类似。")]),a._v(" "),e("p",[a._v("可以看到虽然"),e("code",[a._v("job.content")]),a._v("是一个数组，但是只获取了第一个元素的Reader插件和Writer插件配置，不知道当初为什么这样设计？后面看到可能因为要兼容后面切分后分片的配置，但这里显然是一个设计败笔。")]),a._v(" "),e("p",[a._v("还可以看到Reader插件和Writer插件可以互相看到对方的配置，这样的设计的目的可能是特定的配对可以做一些短路处理，但是互相有了侵入，不认为这是一个好的设计。如何设计能更解耦一点呢？或许可以引入一个中枢性质的类。")]),a._v(" "),e("h3",{attrs:{id:"jobcontainer-prepare-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jobcontainer-prepare-方法"}},[a._v("$")]),a._v(" JobContainer.prepare()方法")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/job/JobContainer.java#L307",target:"_blank",rel:"noopener noreferrer"}},[a._v("JobContainer.prepare()方法"),e("OutboundLink")],1),a._v("分别调用Reader插件和writer插件的"),e("code",[a._v("prepare()")]),a._v("接口。")]),a._v(" "),e("h3",{attrs:{id:"jobcontainer-split-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jobcontainer-split-方法"}},[a._v("$")]),a._v(" JobContainer.split()方法")]),a._v(" "),e("p",[a._v("DataX的数据模型是Reader的一个分片对应一个Writer的分片，中间通过一个Channel交换数据。"),e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/job/JobContainer.java#L386",target:"_blank",rel:"noopener noreferrer"}},[a._v("JobContainer.split()方法"),e("OutboundLink")],1),a._v("主要作用就是切分分片，保证切分后Reader分片和Writer分片比例是"),e("code",[a._v("1:1")]),a._v("。")]),a._v(" "),e("p",[a._v("Channel数根据"),e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/job/JobContainer.java#L416",target:"_blank",rel:"noopener noreferrer"}},[a._v("adjustChannelNumber()"),e("OutboundLink")],1),a._v("里面的算法确定：")]),a._v(" "),e("ol",[e("li",[a._v("如果设置了字节限速，根据字节限速确定：Job级别限速"),e("code",[a._v("job.setting.speed.byte")]),a._v("，Channel级别限速"),e("code",[a._v("core.transport.channel.speed.byte")]),a._v("，Channel数= Job级别限速 / Channel级别限速。")]),a._v(" "),e("li",[a._v("如果设置类记录数限速，根据记录数限速确定：Job级别限速"),e("code",[a._v("job.setting.speed.record")]),a._v("，Channel级别限速"),e("code",[a._v("job.setting.speed.channel")]),a._v("，Channel数= Job级别限速 / Channel级别限速。")]),a._v(" "),e("li",[a._v("取字节限速和记录数限速确定的Channel数两者的最小值。")]),a._v(" "),e("li",[a._v("如果都没有设置，则取"),e("code",[a._v("job.setting.speed.channel")]),a._v("的值作为Channel数，如果"),e("code",[a._v("job.setting.speed.channel")]),a._v("也没有设置则抛出异常。")])]),a._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/job/JobContainer.java#L729",target:"_blank",rel:"noopener noreferrer"}},[a._v("doReaderSplit()方法"),e("OutboundLink")],1),a._v("和"),e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/job/JobContainer.java#L745",target:"_blank",rel:"noopener noreferrer"}},[a._v("doWriterSplit()方法"),e("OutboundLink")],1),a._v("分别调用插件的split()接口。")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/job/JobContainer.java#L770",target:"_blank",rel:"noopener noreferrer"}},[a._v("mergeReaderAndWriterTaskConfigs()方法"),e("OutboundLink")],1),a._v("把同一个Channel的Reader插件、Transformer插件、Writer插件的配置合并到一起。")]),a._v(" "),e("p",[a._v("最后会重新设置全局配置的"),e("code",[a._v("job.content")]),a._v("为切分后的配置数组。估计懒得再重新定义一个配置项名称，这可能就是"),e("code",[a._v("job.content")]),a._v("为什么要设置成为数组的原因吧？")]),a._v(" "),e("h3",{attrs:{id:"jobcontainer-schedule-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jobcontainer-schedule-方法"}},[a._v("$")]),a._v(" JobContainer.schedule()方法")]),a._v(" "),e("p",[a._v("首先明确几个概念：")]),a._v(" "),e("ul",[e("li",[a._v("Task是最小的执行单元，一个Task包含一个Reader分片和一个Writer分片。")]),a._v(" "),e("li",[a._v("TaskGroup是对Task的一个分组，通过控制Channel数来达到限速的目的。")]),a._v(" "),e("li",[a._v("Channel是TaskGroup中Task执行的并发通道。")])]),a._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/job/JobContainer.java#L492",target:"_blank",rel:"noopener noreferrer"}},[a._v("JobContainer.schedule()方法"),e("OutboundLink")],1),a._v("主要流程是确定TaskGroup的数量，把Task均匀分配到TaskGroup中，然后启动线程执行Task。")]),a._v(" "),e("p",[a._v("确定每个TaskGroup的Channel数：获取配置"),e("code",[a._v("core.container.taskGroup.channel")]),a._v("。")]),a._v(" "),e("p",[a._v("重新确定Channel数：取原Channel数和切分的Task数的最小值。")]),a._v(" "),e("h4",{attrs:{id:"jobassignutil-assignfairly-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jobassignutil-assignfairly-方法"}},[a._v("$")]),a._v(" JobAssignUtil.assignFairly()方法")]),a._v(" "),e("p",[a._v("在"),e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/container/util/JobAssignUtil.java#L20",target:"_blank",rel:"noopener noreferrer"}},[a._v("JobAssignUtil.assignFairly()"),e("OutboundLink")],1),a._v("中进行了Task的分配：")]),a._v(" "),e("p",[a._v("确定TaskGroup数：TaskGroup数=Channel数/每个TaskGroup的Channel数")]),a._v(" "),e("p",[a._v("然后就出现了"),e("code",[a._v("resourceMark")]),a._v("这个概念。")]),a._v(" "),e("p",[a._v("在"),e("code",[a._v("parseAndGetResourceMarkAndTaskIdMap()")]),a._v("中分别对Reader插件和Writer插件按照各自的"),e("code",[a._v("resourceMark")]),a._v("对所有分片的taskId进行分组，然后取组数多的得到"),e("code",[a._v("resourceMark")]),a._v("组。")]),a._v(" "),e("p",[a._v("然后在"),e("code",[a._v("doAssign()")]),a._v("中将resourceMark组分配到TaskGroup组中，同时在这里分配TaskGroupId。注意"),e("code",[a._v("resourceMark")]),a._v("组数量和TaskGroup数量不一定是相等的。具体分配算法是什么呢？简单来说就是依次将每个"),e("code",[a._v("resourceMark")]),a._v("组的第一个Task按"),e("code",[a._v("roundrobin")]),a._v("分配到TaskGroup，然后remove掉该Task，直到分配完所有Task。"),e("code",[a._v("JobAssignUtil.doAssign()")]),a._v("的函数文档中给了一个很好的例子：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("需要实现的效果通过例子来说是：\n  a 库上有表：0, 1, 2\n  b 库上有表：3, 4\n  c 库上有表：5, 6, 7\n \n  如果有 4个 taskGroup\n  则 assign 后的结果为：\n  taskGroup-0: 0,  4,\n  taskGroup-1: 3,  6,\n  taskGroup-2: 5,  2,\n  taskGroup-3: 1,  7\n")])])]),e("p",[a._v("依次将0,3,5,1,4,6,2,7分片分配到TaskGroup-0到TaskGroup-4上。")]),a._v(" "),e("p",[a._v("在"),e("code",[a._v("adjustChannelNumPerTaskGroup()")]),a._v("中对taskGroupConfig做了更均匀分配的优化：")]),a._v(" "),e("p",[a._v("为什么要做这个优化呢？")]),a._v(" "),e("h4",{attrs:{id:"standalonescheduler-schedule-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#standalonescheduler-schedule-方法"}},[a._v("$")]),a._v(" StandAloneScheduler.schedule()方法")]),a._v(" "),e("p",[a._v("划分好TaskGroup之后就是初始化具体的Scheduler然后调用"),e("code",[a._v("Scheduler.schedule()")]),a._v("方法进行调度执行了。开源版本的DataX只实现了"),e("code",[a._v("STANDALONE")]),a._v("模式的Scheduler版本，即"),e("code",[a._v("StandAloneScheduler")]),a._v("。")]),a._v(" "),e("h4",{attrs:{id:"processinnerscheduler-startalltaskgroup-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#processinnerscheduler-startalltaskgroup-方法"}},[a._v("$")]),a._v(" ProcessInnerScheduler.startAllTaskGroup()方法")]),a._v(" "),e("p",[e("code",[a._v("ProcessInnerScheduler.startAllTaskGroup()")]),a._v("中启动了一个固定数线程池提交TaskGroupContainerRunner，线程池的线程数就是TaskGroup的数目，后续不会再有新的执行请求进来，因此提交之后就可以调用线程池的"),e("code",[a._v("shutdown()")]),a._v("等待线程运行完自己结束。")]),a._v(" "),e("p",[e("code",[a._v("TaskGroupContainerRunner")]),a._v("则是负责启动"),e("code",[a._v("TaskGroupContainer")]),a._v("，"),e("code",[a._v("TaskGroupContainer")]),a._v("会调度该TaskGroup上的任务执行。")]),a._v(" "),e("h4",{attrs:{id:"taskgroupcontainer-start-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#taskgroupcontainer-start-方法"}},[a._v("$")]),a._v(" TaskGroupContainer.start()方法")]),a._v(" "),e("p",[a._v("这块代码算是调度模块的核心代码逻辑。TaskGroupContainer通过调度TaskExecutor来调度同一个TaskGroup的Task的执行，"),e("code",[a._v("TaskExecutor")]),a._v("是单个Task的执行器。其中有几个变量：")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("runTasks")]),a._v("是正在执行的Task列表")]),a._v(" "),e("li",[e("code",[a._v("taskQueue")]),a._v("是待执行的Task列表")]),a._v(" "),e("li",[e("code",[a._v("communicationMap")]),a._v("存放taskId和对应的Communication的映射，Communication可以获取到Task执行状态")])]),a._v(" "),e("p",[a._v("主逻辑在一个死循环中不断轮询，分为以下几步：")]),a._v(" "),e("ol",[e("li",[a._v("查询所有Task的状态，从"),e("code",[a._v("runTasks")]),a._v("中移除已经结束的Task。如果：\n"),e("ol",[e("li",[a._v("Task是失败状态且支持failover，且没有超过最大重试次数，则将Task的状态重置，重新加入"),e("code",[a._v("taskQueue")]),a._v("列表")]),a._v(" "),e("li",[a._v("如果Task最终失败了，或者被kill了，则抛出异常终止任务")])])]),a._v(" "),e("li",[a._v("如果"),e("code",[a._v("runTasks")]),a._v("数量小于设定的channel数则从"),e("code",[a._v("taskQueue")]),a._v("拉取Task，再判断是否为重试Task：\n"),e("ol",[e("li",[a._v("如果是重试Task，先判断是否等待超过重试间隔时间，如果没有则继续留在"),e("code",[a._v("taskQueue")]),a._v("队列，如果超过了则判断上次执行的TaskExecutor的线程是否已经都退出。")]),a._v(" "),e("li",[a._v("封装为TaskExecutor，调用"),e("code",[a._v("taskExecutor.doStart()")]),a._v("执行，同时加入"),e("code",[a._v("runTasks")]),a._v("列表。")])])])]),a._v(" "),e("p",[a._v("这里有个细节可以注意下，同一个Task的重试前后要保证不会同时在执行，需要根据线程的"),e("code",[a._v("isAlive()")]),a._v("判断，而不是让线程触发中断之后就默认线程已经关闭。")]),a._v(" "),e("h3",{attrs:{id:"jobcontainer-post-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jobcontainer-post-方法"}},[a._v("$")]),a._v(" JobContainer.post()方法")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/job/JobContainer.java#L559",target:"_blank",rel:"noopener noreferrer"}},[a._v("JobContainer.post()方法"),e("OutboundLink")],1),a._v("分别调用Reader插件和Writer插件的"),e("code",[a._v("post()")]),a._v("接口。")]),a._v(" "),e("h3",{attrs:{id:"jobcontainer-posthandle-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jobcontainer-posthandle-方法"}},[a._v("$")]),a._v(" JobContainer.postHandle()方法")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/job/JobContainer.java#L347",target:"_blank",rel:"noopener noreferrer"}},[a._v("JobContainer.postHandle()方法"),e("OutboundLink")],1),a._v("根据配置里面的"),e("code",[a._v("job.postHandler.pluginType")]),a._v("和"),e("code",[a._v("job.postHandler.pluginName")]),a._v("获取到Handler的类型和名称，然后调用自定义的ClassLoader加载对应的类，并调用postHandler()接口。")]),a._v(" "),e("h3",{attrs:{id:"jobcontainer-invokehooks-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jobcontainer-invokehooks-方法"}},[a._v("$")]),a._v(" JobContainer.invokeHooks()方法")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/alibaba/DataX/blob/datax_v202309/core/src/main/java/com/alibaba/datax/core/job/JobContainer.java#L971",target:"_blank",rel:"noopener noreferrer"}},[a._v("JobContainer.invokeHooks()方法"),e("OutboundLink")],1),a._v("加载"),e("code",[a._v("${DATAX_HOME}/hook")]),a._v("目录下子目录里的jar,通过SPI机制加载Hook接口，并调用"),e("code",[a._v("Hook.invoke()")]),a._v("方法。")]),a._v(" "),e("h3",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("$")]),a._v(" 总结")]),a._v(" "),e("p",[a._v("整个流程看下来似乎"),e("code",[a._v("init()")]),a._v("接口和"),e("code",[a._v("prepare()")]),a._v("接口都是Reader或者Writer插件各自的无参接口，都是在调度执行前执行的，功能有点重复了。")]),a._v(" "),e("p",[a._v("另外PreHandler和PostHandler插件的功能是做什么用的？和Reader或者Writer插件在数据流上似乎又没有衔接，看起来很鸡肋。")]),a._v(" "),e("h2",{attrs:{id:"类隔离"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类隔离"}},[a._v("$")]),a._v(" 类隔离")]),a._v(" "),e("h2",{attrs:{id:"类型转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型转换"}},[a._v("$")]),a._v(" 类型转换")]),a._v(" "),e("h2",{attrs:{id:"异常处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异常处理"}},[a._v("$")]),a._v(" 异常处理")]),a._v(" "),e("h2",{attrs:{id:"configuration类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#configuration类"}},[a._v("$")]),a._v(" Configuration类")]),a._v(" "),e("h2",{attrs:{id:"communacation类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#communacation类"}},[a._v("$")]),a._v(" Communacation类")]),a._v(" "),e("h2",{attrs:{id:"总结-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[a._v("$")]),a._v(" 总结")]),a._v(" "),e("p",[a._v("DataX最亮眼的地方就是API的设计。阿里的工程师创新性地提出了这样一个星形的数据模型，将从数据源读取和写入操作自然地抽象为Reader和Writer接口，可谓精妙绝伦。")]),a._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("$")]),a._v(" 参考")])])}),[],!1,null,null,null);e.default=o.exports}}]);