(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{423:function(_,t,v){_.exports=v.p+"assets/img/dirty_read.567a57a4.png"},424:function(_,t,v){_.exports=v.p+"assets/img/unrepeated_read.4c743973.png"},629:function(_,t,v){"use strict";v.r(t);var r=v(10),a=Object(r.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"数据库事务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库事务"}},[_._v("$")]),_._v(" 数据库事务")]),_._v(" "),t("h2",{attrs:{id:"事务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[_._v("$")]),_._v(" 事务")]),_._v(" "),t("p",[t("strong",[_._v("事务开始于：")])]),_._v(" "),t("ul",[t("li",[_._v("连接到数据库上，并执行一条DML语句insert、update或delete")]),_._v(" "),t("li",[_._v("前一个事务结束后，又输入了另一条DML语句")])]),_._v(" "),t("p",[t("strong",[_._v("事务结束于：")])]),_._v(" "),t("ul",[t("li",[_._v("执行commit或rollback语句。")]),_._v(" "),t("li",[_._v("执行一条DDL语句，例如create table，grant语句，在这种情况下，会自动执行commit语句。")]),_._v(" "),t("li",[_._v("断开与数据库的连接")]),_._v(" "),t("li",[_._v("执行了一条DML语句，该语句却失败了，在这种情况中，会为这个无效的DML语句执行rollback语句。")])]),_._v(" "),t("p",[t("strong",[_._v("事务的四大特点（ACID）")])]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("actomicity(原子性)")]),_._v("　表示一个事务内的所有操作是一个整体，要么全部成功，要么全部失败")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("consistency(一致性)")]),_._v("　表示一个事务内有一个操作失败时，所有的更改过的数据都必须回滚到修改前状态")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("isolation(隔离性)")]),_._v(" 事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("durability(持久性)")]),_._v("　持久性事务完成之后，它对于系统的影响是永久性的。")])])]),_._v(" "),t("p",[t("strong",[_._v("隔离级别")])]),_._v(" "),t("p",[_._v("com.mysql.jdbc.Connection的定义有5个级别:")]),_._v(" "),t("ol",[t("li",[_._v("TRANSACTION_NONE(不支持事务)")]),_._v(" "),t("li",[_._v("TRANSACTION_READ_UNCOMMITTED")]),_._v(" "),t("li",[_._v("TRANSACTION_READ_COMMITTED")]),_._v(" "),t("li",[_._v("TRANSACTION_REPEATABLE_READ")]),_._v(" "),t("li",[_._v("TRANSACTION_SERIALIZABLE")])]),_._v(" "),t("p",[t("strong",[_._v("脏读")])]),_._v(" "),t("p",[_._v("事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。")]),_._v(" "),t("p",[t("img",{attrs:{src:v(423),alt:"脏读"}})]),_._v(" "),t("p",[t("strong",[_._v("不可重复读")])]),_._v(" "),t("p",[_._v("在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和事务A提交后读到的结果可能不同。")]),_._v(" "),t("p",[t("img",{attrs:{src:v(424),alt:"不可重复读"}})]),_._v(" "),t("p",[t("strong",[_._v("幻读")])]),_._v(" "),t("p",[_._v("在事务中，前后两次查询，记录数量是不一样的。不可重复读的和幻读很容易混淆，不可重复读侧重于 "),t("strong",[_._v("修改")]),_._v(" ，幻读侧重于 "),t("strong",[_._v("新增或删除")]),_._v(" 。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要 "),t("strong",[_._v("锁表")]),_._v(" 。")]),_._v(" "),t("p",[t("strong",[_._v("mysql的可重复读一并解决了幻读的问题。")])]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("隔离级别")]),_._v(" "),t("th"),_._v(" "),t("th",[_._v("脏读")]),_._v(" "),t("th",[_._v("不可重复读")]),_._v(" "),t("th",[_._v("幻读")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("未提交读")]),_._v(" "),t("td",[_._v("READ_UNCOMMITTED")]),_._v(" "),t("td",[_._v("T")]),_._v(" "),t("td",[_._v("T")]),_._v(" "),t("td",[_._v("T")])]),_._v(" "),t("tr",[t("td",[_._v("提交读")]),_._v(" "),t("td",[_._v("READ_COMMITTED")]),_._v(" "),t("td"),_._v(" "),t("td",[_._v("T")]),_._v(" "),t("td",[_._v("T")])]),_._v(" "),t("tr",[t("td",[_._v("可重复读")]),_._v(" "),t("td",[_._v("REPEATABLE_READ")]),_._v(" "),t("td"),_._v(" "),t("td"),_._v(" "),t("td",[_._v("T(MySQL为F)")])]),_._v(" "),t("tr",[t("td",[_._v("可串行化")]),_._v(" "),t("td",[_._v("SERIALIZABLE")]),_._v(" "),t("td"),_._v(" "),t("td"),_._v(" "),t("td")])])]),_._v(" "),t("h2",{attrs:{id:"mvcc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvcc"}},[_._v("$")]),_._v(" MVCC")]),_._v(" "),t("h3",{attrs:{id:"解决的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决的问题"}},[_._v("$")]),_._v(" 解决的问题")]),_._v(" "),t("p",[_._v("数据库并发3种场景：")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("场景")]),_._v(" "),t("th",[_._v("存在问题")]),_._v(" "),t("th",[_._v("并发控制")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("读读")]),_._v(" "),t("td",[_._v("无")]),_._v(" "),t("td",[_._v("不需要")])]),_._v(" "),t("tr",[t("td",[_._v("读写")]),_._v(" "),t("td",[_._v("事务隔离性问题：脏读，幻读，不可重复读")]),_._v(" "),t("td",[_._v("需要")])]),_._v(" "),t("tr",[t("td",[_._v("写写")]),_._v(" "),t("td",[_._v("更新丢失问题")]),_._v(" "),t("td",[_._v("需要")])])])]),_._v(" "),t("p",[_._v("MVCC是一种用来解决读写冲突的无锁并发控制。也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库快照。")]),_._v(" "),t("p",[_._v("所以MVCC可以为数据库解决以下问题：")]),_._v(" "),t("ol",[t("li",[_._v("在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能")]),_._v(" "),t("li",[_._v("解决脏读、幻读、不可重复读的事务隔离问题，但是不能解决更新丢失问题")])]),_._v(" "),t("h3",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[_._v("$")]),_._v(" 参考")]),_._v(" "),t("p",[t("a",{attrs:{href:"https://www.zhihu.com/zvideo/1388975544206282752",target:"_blank",rel:"noopener noreferrer"}},[_._v("MVCC解决的问题是什么？"),t("OutboundLink")],1)]),_._v(" "),t("p",[t("a",{attrs:{href:"https://www.zhihu.com/question/27876575",target:"_blank",rel:"noopener noreferrer"}},[_._v("乐观锁和 MVCC 的区别？"),t("OutboundLink")],1)]),_._v(" "),t("p",[t("a",{attrs:{href:"https://www.huaweicloud.com/articles/d4b79174452538b68954fea1b406b303.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("华为云 MVCC"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);