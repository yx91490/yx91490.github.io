(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{533:function(t,v,_){"use strict";_.r(v);var r=_(10),n=Object(r.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"concurrenthashmap原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap原理"}},[t._v("$")]),t._v(" ConcurrentHashMap原理")]),t._v(" "),v("h3",{attrs:{id:"synchronized"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#synchronized"}},[t._v("$")]),t._v(" synchronized")]),t._v(" "),v("p",[v("strong",[t._v("synchronized是可重入锁")])]),t._v(" "),v("ol",[v("li",[t._v("在Java内部，同一个线程调用自己类中其他synchronized方法/块时不会阻碍该线程的执行，同一个线程对同一个对象锁是可重入的，同一个线程可以获取同一把锁多次，也就是可以多次重入。原因是Java中线程获得对象锁的操作是以线程为单位的，而不是以调用为单位的。")])]),t._v(" "),v("h3",{attrs:{id:"reentrantlock"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock"}},[t._v("$")]),t._v(" ReentrantLock")]),t._v(" "),v("p",[t._v("ReentrantLock 的主要功能和 synchronized 关键字一致，均是用于多线程的同步。但除此之外，ReentrantLock 在功能上比 synchronized 更为丰富。比如 ReentrantLock 在加锁期间，可响应中断，可设置超时等。")]),t._v(" "),v("p",[v("strong",[t._v("与synchronized对比")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("特性")]),t._v(" "),v("th",[t._v("synchronized")]),t._v(" "),v("th",[t._v("ReentrantLock")]),t._v(" "),v("th",[t._v("相同")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("可重入")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td",[t._v("✅")])]),t._v(" "),v("tr",[v("td",[t._v("响应中断")]),t._v(" "),v("td",[t._v("否")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td",[t._v("❌")])]),t._v(" "),v("tr",[v("td",[t._v("超时等待")]),t._v(" "),v("td",[t._v("否")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td",[t._v("❌")])]),t._v(" "),v("tr",[v("td",[t._v("公平锁")]),t._v(" "),v("td",[t._v("否")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td",[t._v("❌")])]),t._v(" "),v("tr",[v("td",[t._v("非公平锁")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td",[t._v("✅")])]),t._v(" "),v("tr",[v("td",[t._v("是否可尝试加锁")]),t._v(" "),v("td",[t._v("否")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td",[t._v("❌")])]),t._v(" "),v("tr",[v("td",[t._v("是否是Java内置特性")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td",[t._v("否")]),t._v(" "),v("td",[t._v("❌")])]),t._v(" "),v("tr",[v("td",[t._v("自动获取/释放锁")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td",[t._v("否")]),t._v(" "),v("td",[t._v("❌")])]),t._v(" "),v("tr",[v("td",[t._v("对异常的处理")]),t._v(" "),v("td",[t._v("自动释放锁")]),t._v(" "),v("td",[t._v("需手动释放锁")]),t._v(" "),v("td",[t._v("❌")])])])]),t._v(" "),v("p",[v("strong",[t._v("公平与非公平")])]),t._v(" "),v("p",[t._v("公平与非公平指的是线程获取锁的方式。公平模式下，线程在同步队列中通过 FIFO 的方式获取锁，每个线程最终都能获取锁。在非公平模式下，线程会通过“插队”的方式去抢占锁，抢不到的则进入同步队列进行排队。")]),t._v(" "),v("p",[t._v("默认情况下，ReentrantLock 使用的是非公平模式获取锁，而不是公平模式。不过我们也可通过 ReentrantLock 构造方法 "),v("code",[t._v("ReentrantLock(boolean fair)")]),t._v(" 调整加锁的模式。")])])}),[],!1,null,null,null);v.default=n.exports}}]);