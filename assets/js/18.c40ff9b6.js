(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{361:function(t,_,v){t.exports=v.p+"assets/img/image-20210830112552811.44425d10.png"},362:function(t,_,v){t.exports=v.p+"assets/img/SouthEast.864461db.png"},363:function(t,_,v){t.exports=v.p+"assets/img/874963-20191013161502813-675093298.09bcef66.png"},515:function(t,_,v){"use strict";v.r(_);var r=v(10),a=Object(r.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"数据结构与算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据结构与算法"}},[t._v("$")]),t._v(" 数据结构与算法")]),t._v(" "),_("h2",{attrs:{id:"算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[t._v("$")]),t._v(" 算法")]),t._v(" "),_("h3",{attrs:{id:"排序算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#排序算法"}},[t._v("$")]),t._v(" 排序算法")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("插入排序")]),t._v(" "),_("ul",[_("li",[t._v("直接插入排序")]),t._v(" "),_("li",[t._v("折半插入排序")]),t._v(" "),_("li",[t._v("2-路插入排序")]),t._v(" "),_("li",[t._v("希尔排序")])])]),t._v(" "),_("li",[_("p",[t._v("交换类")]),t._v(" "),_("ul",[_("li",[t._v("冒泡排序")]),t._v(" "),_("li",[t._v("快速排序")])])]),t._v(" "),_("li",[_("p",[t._v("选择排序")]),t._v(" "),_("ul",[_("li",[t._v("简单选择排序")]),t._v(" "),_("li",[t._v("锦标赛排序（树形选择排序）")]),t._v(" "),_("li",[t._v("堆排序")])])]),t._v(" "),_("li",[_("p",[t._v("归并排序")])]),t._v(" "),_("li",[_("p",[t._v("基数排序")])])]),t._v(" "),_("p",[t._v("比较：")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("算法")]),t._v(" "),_("th",[t._v("稳定性")]),t._v(" "),_("th",[t._v("时间复杂度（平均/最好/最坏）")]),t._v(" "),_("th",[t._v("空间复杂度")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("简单排序（除希尔排序）")]),t._v(" "),_("td",[t._v("T")]),t._v(" "),_("td",[t._v("O(n^2^)")]),t._v(" "),_("td",[t._v("O(1)")])]),t._v(" "),_("tr",[_("td",[t._v("快速排序")]),t._v(" "),_("td",[t._v("F")]),t._v(" "),_("td",[t._v("O(nlogn)/O(n^2^)")]),t._v(" "),_("td",[t._v("O(logn)")])]),t._v(" "),_("tr",[_("td",[t._v("堆排序")]),t._v(" "),_("td",[t._v("F")]),t._v(" "),_("td",[t._v("O(nlogn)")]),t._v(" "),_("td",[t._v("O(1)")])]),t._v(" "),_("tr",[_("td",[t._v("归并排序")]),t._v(" "),_("td"),t._v(" "),_("td",[t._v("O(nlogn)")]),t._v(" "),_("td",[t._v("O(n)")])]),t._v(" "),_("tr",[_("td",[t._v("基数排序")]),t._v(" "),_("td",[t._v("T")]),t._v(" "),_("td",[t._v("O(d(n+rd))")]),t._v(" "),_("td",[t._v("O(rd)")])])])]),t._v(" "),_("h3",{attrs:{id:"堆排序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆排序"}},[t._v("$")]),t._v(" 堆排序")]),t._v(" "),_("p",[t._v("堆有以下两个特性：")]),t._v(" "),_("ol",[_("li",[t._v("它是一个完全二叉树")]),t._v(" "),_("li",[t._v("堆中的任意一个父节点的值都大于等于（或小于）它的左右孩子节点。")])]),t._v(" "),_("p",[t._v("因此，根据第二个特性，就把二叉堆分为大顶堆（或叫最大堆），和小顶堆（或叫最小堆）。")]),t._v(" "),_("p",[t._v("堆排序的过程：")]),t._v(" "),_("ol",[_("li",[t._v("将一颗完全二叉树构建成堆")]),t._v(" "),_("li",[t._v("循环获取堆顶的最大值放到堆的后面，并重建堆。")])]),t._v(" "),_("h2",{attrs:{id:"数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("$")]),t._v(" 数据结构")]),t._v(" "),_("h3",{attrs:{id:"二叉树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[t._v("$")]),t._v(" 二叉树")]),t._v(" "),_("p",[t._v("定义：每个节点最多只有两颗子树，并且二叉树的子树有左右之分。")]),t._v(" "),_("p",[t._v("性质：")]),t._v(" "),_("ol",[_("li",[t._v("第"),_("code",[t._v("i")]),t._v("层至多有2^i-1^个结点("),_("code",[t._v("i >= 1")]),t._v(") （归纳法证明）")]),t._v(" "),_("li",[t._v("深度为k的二叉树至多有2^k^ - 1个结点（k >= 1）")]),t._v(" "),_("li",[t._v("N~0~(终端结点数) = N~2~ (度为2的结点数) + 1")]),t._v(" "),_("li",[t._v("具有N个结点的完全二叉树的深度为floor(log~2~N) + 1")]),t._v(" "),_("li",[t._v("如果对一颗有n个结点的完全二叉树编号，对任一结点i（1 <= i <= n）有：\n"),_("ol",[_("li",[t._v("parent(i) 是 floor(i / 2) （i < 1）")]),t._v(" "),_("li",[t._v("如果n < 2i, 则结点无左孩子；否则其左孩子为2i")]),t._v(" "),_("li",[t._v("如果n < 2i + 1, 则结点无右孩子；否则其左孩子为2i + 1")])])])]),t._v(" "),_("p",[t._v("遍历：分为先序遍历，中序遍历，后序遍历")]),t._v(" "),_("h3",{attrs:{id:"bitmap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bitmap"}},[t._v("$")]),t._v(" BitMap")]),t._v(" "),_("p",[t._v("用于大量数据的快速排序、查找、去重。")]),t._v(" "),_("p",[t._v("RoaringBitmap的主要思路是：将32位无符号整数按照高16位分桶，即最多可能有216=65536个桶，论文内称为container。存储数据时，按照数据的高16位找到container（找不到就会新建一个），再将低16位放入container中。也就是说，一个RoaringBitmap就是很多container的集合。")]),t._v(" "),_("p",[t._v("为了方便理解，照搬论文中的示例图，如下所示。")]),t._v(" "),_("img",{staticStyle:{zoom:"33%"},attrs:{src:v(361),alt:"image-20210830112552811"}}),t._v(" "),_("p",[t._v("图中示出了三个container：")]),t._v(" "),_("ul",[_("li",[t._v("高16位为0000H的container，存储有前1000个62的倍数。")]),t._v(" "),_("li",[t._v("高16位为0001H的container，存储有[216, 216+100)区间内的100个数。")]),t._v(" "),_("li",[t._v("高16位为0002H的container，存储有[2×216, 3×216)区间内的所有偶数，共215个。")])]),t._v(" "),_("p",[t._v("Container一共有3种：")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("类型")]),t._v(" "),_("th",[t._v("数据结构")]),t._v(" "),_("th",[t._v("增删改查的时间复杂度")]),t._v(" "),_("th",[t._v("空间复杂度")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("ArrayContainer")]),t._v(" "),_("td",[t._v("unsigned short类型的有序数组")]),t._v(" "),_("td",[t._v("O(logN)")]),t._v(" "),_("td",[t._v("(2 + 2 * 基数)B")])]),t._v(" "),_("tr",[_("td",[t._v("BitmapContainer")]),t._v(" "),_("td",[t._v("长度固定为1024的unsigned long型数组")]),t._v(" "),_("td",[t._v("O(1)")]),t._v(" "),_("td",[t._v("8192B")])]),t._v(" "),_("tr",[_("td",[t._v("RunContainer")]),t._v(" "),_("td",[t._v("用可变长度的unsigned short数组存储用行程长度编码（RLE）压缩后的数据")]),t._v(" "),_("td",[t._v("O(logN)")]),t._v(" "),_("td",[t._v("(2 + 4 * 连续序列数)B")])])])]),t._v(" "),_("p",[t._v("创建时：")]),t._v(" "),_("ul",[_("li",[t._v("创建包含单个值的Container时，选用ArrayContainer")]),t._v(" "),_("li",[t._v("创建包含一串连续值的Container时，比较ArrayContainer和RunContainer，选取空间占用较少的")])]),t._v(" "),_("p",[t._v("转换：")]),t._v(" "),_("p",[t._v("针对ArrayContainer：")]),t._v(" "),_("p",[t._v("如果插入值后容量超过4096，则自动转换为BitmapContainer。因此正常使用的情况下不会出现容量超过4096的ArrayContainer。\n调用runOptimize()方法时，会比较和RunContainer的空间占用大小，选择是否转换为RunContainer。\n针对BitmapContainer：")]),t._v(" "),_("p",[t._v("如果删除某值后容量低至4096，则会自动转换为ArrayContainer。因此正常使用的情况下不会出现容量小于4096的BitmapContainer。\n调用runOptimize()方法时，会比较和RunContainer的空间占用大小，选择是否转换为RunContainer。\n针对RunContainer：")]),t._v(" "),_("p",[t._v("只有在调用runOptimize()方法才会发生转换，会分别和ArrayContainer、BitmapContainer比较空间占用大小，然后选择是否转换。")]),t._v(" "),_("img",{staticStyle:{zoom:"33%"},attrs:{src:v(362),alt:"Container内存比较"}}),t._v(" "),_("h4",{attrs:{id:"参考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("$")]),t._v(" 参考")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://www.jianshu.com/p/818ac4e90daf",target:"_blank",rel:"noopener noreferrer"}},[t._v("高效压缩位图RoaringBitmap的原理与应用"),_("OutboundLink")],1)]),t._v(" "),_("p",[_("a",{attrs:{href:"https://blog.csdn.net/yizishou/article/details/78342499",target:"_blank",rel:"noopener noreferrer"}},[t._v("RoaringBitmap数据结构及原理"),_("OutboundLink")],1)]),t._v(" "),_("p",[_("a",{attrs:{href:"https://cn.kyligence.io/blog/count-distinct-bitmap/",target:"_blank",rel:"noopener noreferrer"}},[t._v("大数据分析常用去重算法分析『Bitmap 篇』"),_("OutboundLink")],1)]),t._v(" "),_("h3",{attrs:{id:"bloomfilter"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bloomfilter"}},[t._v("$")]),t._v(" BloomFilter")]),t._v(" "),_("p",[t._v("Bloom filter 是一个数据结构，它可以用来判断某个元素是否在集合内，具有运行快速，内存占用小的特点。")]),t._v(" "),_("p",[t._v("而高效插入和查询的代价就是，Bloom Filter 是一个基于概率的数据结构：它只能告诉我们一个元素绝对不在集合内或可能在集合内。")]),t._v(" "),_("p",[t._v("Bloom filter 的基础数据结构是一个 比特向量（可理解为数组）。")]),t._v(" "),_("p",[t._v("缺点：")]),t._v(" "),_("ul",[_("li",[t._v("只能插入元素，不能删除元素；")]),t._v(" "),_("li",[t._v("不保证100%准确，总是存在误差。")])]),t._v(" "),_("p",[t._v("BloomFilter 流程：")]),t._v(" "),_("ol",[_("li",[t._v("首先需要 k 个 hash 函数，每个函数可以把 key 散列成为 1 个整数；")]),t._v(" "),_("li",[t._v("初始化时，需要一个长度为 n 比特的数组，每个比特位初始化为 0；")]),t._v(" "),_("li",[t._v("某个 key 加入集合时，用 k 个 hash 函数计算出 k 个散列值，并把数组中对应的比特位置为 1；")]),t._v(" "),_("li",[t._v("判断某个 key 是否在集合时，用 k 个 hash 函数计算出 k 个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。")])]),t._v(" "),_("p",[_("img",{attrs:{src:v(363),alt:"img"}})]),t._v(" "),_("h4",{attrs:{id:"参考-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考-2"}},[t._v("$")]),t._v(" 参考")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://www.cnblogs.com/cjsblog/p/11613708.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("4.  Bloom Filters"),_("OutboundLink")],1)]),t._v(" "),_("p",[_("a",{attrs:{href:"https://www.jianshu.com/p/818ac4e90daf",target:"_blank",rel:"noopener noreferrer"}},[t._v("高效压缩位图RoaringBitmap的原理与应用"),_("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=a.exports}}]);