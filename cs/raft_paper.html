<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>In Search of an Understandable Consensus  Algorithm(Extended Version) | yx91490的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/logo.webp">
    <script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QQHZM2VLM0');
window.addEventListener('load', function(){ var s = document.createElement('script'); s.src = "https://www.googletagmanager.com/gtag/js?id=G-QQHZM2VLM0"; document.body.appendChild(s); });</script>
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6781d2ac2dff1f3b278518419b4d4deb";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <meta name="description" content="java, 大数据(hadoop, sqoop, kylin, zeppelin)相关技术, 工作经验记录">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="google-site-verification" content="j1Gm2ZeMV3D7mPiI08fpx91dEOSlhCAJjD4vy_pSroQ">
    <meta name="baidu-site-verification" content="4z2bGbjYMB">
    
    <link rel="preload" href="/assets/css/0.styles.003598ab.css" as="style"><link rel="preload" href="/assets/js/app.a2246195.js" as="script"><link rel="preload" href="/assets/js/2.a92520c9.js" as="script"><link rel="preload" href="/assets/js/3.cd488c94.js" as="script"><link rel="prefetch" href="/assets/js/10.9266ea66.js"><link rel="prefetch" href="/assets/js/100.be2d6fa9.js"><link rel="prefetch" href="/assets/js/101.6bf96f53.js"><link rel="prefetch" href="/assets/js/102.b9123862.js"><link rel="prefetch" href="/assets/js/103.3393f6b3.js"><link rel="prefetch" href="/assets/js/104.684c4331.js"><link rel="prefetch" href="/assets/js/105.50f83af8.js"><link rel="prefetch" href="/assets/js/106.af1be028.js"><link rel="prefetch" href="/assets/js/107.03a88e14.js"><link rel="prefetch" href="/assets/js/108.3c9beac7.js"><link rel="prefetch" href="/assets/js/109.1cc12551.js"><link rel="prefetch" href="/assets/js/11.abfb5926.js"><link rel="prefetch" href="/assets/js/110.6496c428.js"><link rel="prefetch" href="/assets/js/111.441b5c62.js"><link rel="prefetch" href="/assets/js/112.c176e7aa.js"><link rel="prefetch" href="/assets/js/113.22b25ffa.js"><link rel="prefetch" href="/assets/js/114.0470f0e2.js"><link rel="prefetch" href="/assets/js/115.133edcde.js"><link rel="prefetch" href="/assets/js/116.5de552b8.js"><link rel="prefetch" href="/assets/js/117.17a14c4a.js"><link rel="prefetch" href="/assets/js/118.c79d4a77.js"><link rel="prefetch" href="/assets/js/119.3a636690.js"><link rel="prefetch" href="/assets/js/12.274720a3.js"><link rel="prefetch" href="/assets/js/120.41a0252a.js"><link rel="prefetch" href="/assets/js/121.18dd56cb.js"><link rel="prefetch" href="/assets/js/122.dcc6fff9.js"><link rel="prefetch" href="/assets/js/123.3e8dd2b0.js"><link rel="prefetch" href="/assets/js/124.c469f9a0.js"><link rel="prefetch" href="/assets/js/125.eb8238e4.js"><link rel="prefetch" href="/assets/js/126.c8b54275.js"><link rel="prefetch" href="/assets/js/127.a9895d7f.js"><link rel="prefetch" href="/assets/js/128.ad16504e.js"><link rel="prefetch" href="/assets/js/129.673ac57e.js"><link rel="prefetch" href="/assets/js/13.473bd291.js"><link rel="prefetch" href="/assets/js/130.9e56a52b.js"><link rel="prefetch" href="/assets/js/131.5423b009.js"><link rel="prefetch" href="/assets/js/132.6438550e.js"><link rel="prefetch" href="/assets/js/133.083d70f2.js"><link rel="prefetch" href="/assets/js/134.80f4d86d.js"><link rel="prefetch" href="/assets/js/135.0368a605.js"><link rel="prefetch" href="/assets/js/136.65c70e71.js"><link rel="prefetch" href="/assets/js/137.676f7436.js"><link rel="prefetch" href="/assets/js/138.d3c68759.js"><link rel="prefetch" href="/assets/js/139.f163f9ac.js"><link rel="prefetch" href="/assets/js/14.4157d143.js"><link rel="prefetch" href="/assets/js/140.0eb4db22.js"><link rel="prefetch" href="/assets/js/141.91c9c472.js"><link rel="prefetch" href="/assets/js/142.ac3a9a62.js"><link rel="prefetch" href="/assets/js/143.156c5dd3.js"><link rel="prefetch" href="/assets/js/144.9117b752.js"><link rel="prefetch" href="/assets/js/145.bf4177dc.js"><link rel="prefetch" href="/assets/js/146.a4e70b4c.js"><link rel="prefetch" href="/assets/js/147.e7503515.js"><link rel="prefetch" href="/assets/js/148.550bb88e.js"><link rel="prefetch" href="/assets/js/149.a3efa6a5.js"><link rel="prefetch" href="/assets/js/15.78885f92.js"><link rel="prefetch" href="/assets/js/150.2b8684be.js"><link rel="prefetch" href="/assets/js/151.723ee132.js"><link rel="prefetch" href="/assets/js/152.2e61447b.js"><link rel="prefetch" href="/assets/js/153.a87224a2.js"><link rel="prefetch" href="/assets/js/154.45b73d0e.js"><link rel="prefetch" href="/assets/js/155.2a158d8e.js"><link rel="prefetch" href="/assets/js/156.6d290334.js"><link rel="prefetch" href="/assets/js/157.dc0ac8e3.js"><link rel="prefetch" href="/assets/js/158.ad8be92a.js"><link rel="prefetch" href="/assets/js/159.17aa0be5.js"><link rel="prefetch" href="/assets/js/16.e9de9925.js"><link rel="prefetch" href="/assets/js/160.f1c672b5.js"><link rel="prefetch" href="/assets/js/161.fced35d3.js"><link rel="prefetch" href="/assets/js/162.14034b66.js"><link rel="prefetch" href="/assets/js/163.b7b22626.js"><link rel="prefetch" href="/assets/js/164.c979848e.js"><link rel="prefetch" href="/assets/js/165.f3b605f4.js"><link rel="prefetch" href="/assets/js/166.31241d54.js"><link rel="prefetch" href="/assets/js/167.99665073.js"><link rel="prefetch" href="/assets/js/168.73a40652.js"><link rel="prefetch" href="/assets/js/169.c6b27f11.js"><link rel="prefetch" href="/assets/js/17.8b238f2d.js"><link rel="prefetch" href="/assets/js/170.9356cc22.js"><link rel="prefetch" href="/assets/js/171.f8f9eeeb.js"><link rel="prefetch" href="/assets/js/172.31967fe5.js"><link rel="prefetch" href="/assets/js/173.6dc70b37.js"><link rel="prefetch" href="/assets/js/174.bad7f12b.js"><link rel="prefetch" href="/assets/js/175.03194976.js"><link rel="prefetch" href="/assets/js/176.5c7853ba.js"><link rel="prefetch" href="/assets/js/177.fc5d3911.js"><link rel="prefetch" href="/assets/js/178.1b8f2927.js"><link rel="prefetch" href="/assets/js/179.7e2010d2.js"><link rel="prefetch" href="/assets/js/18.be942caa.js"><link rel="prefetch" href="/assets/js/180.7fc4904d.js"><link rel="prefetch" href="/assets/js/181.3aa48343.js"><link rel="prefetch" href="/assets/js/182.0da27206.js"><link rel="prefetch" href="/assets/js/183.ea56bc10.js"><link rel="prefetch" href="/assets/js/184.1ba34ef7.js"><link rel="prefetch" href="/assets/js/185.ef514255.js"><link rel="prefetch" href="/assets/js/186.10a22983.js"><link rel="prefetch" href="/assets/js/187.24412415.js"><link rel="prefetch" href="/assets/js/188.9e67f04e.js"><link rel="prefetch" href="/assets/js/189.1a001954.js"><link rel="prefetch" href="/assets/js/19.41661090.js"><link rel="prefetch" href="/assets/js/190.938fd53d.js"><link rel="prefetch" href="/assets/js/191.6036e1aa.js"><link rel="prefetch" href="/assets/js/192.20aaab8b.js"><link rel="prefetch" href="/assets/js/193.1b7ea98e.js"><link rel="prefetch" href="/assets/js/194.1170ccd0.js"><link rel="prefetch" href="/assets/js/195.2da46799.js"><link rel="prefetch" href="/assets/js/196.8c38b115.js"><link rel="prefetch" href="/assets/js/197.c1f360eb.js"><link rel="prefetch" href="/assets/js/198.ab460869.js"><link rel="prefetch" href="/assets/js/199.58b8a906.js"><link rel="prefetch" href="/assets/js/20.7dbafc6d.js"><link rel="prefetch" href="/assets/js/200.a9de3e1c.js"><link rel="prefetch" href="/assets/js/201.9c11ec9b.js"><link rel="prefetch" href="/assets/js/202.31a20041.js"><link rel="prefetch" href="/assets/js/203.561fefc2.js"><link rel="prefetch" href="/assets/js/204.e044c696.js"><link rel="prefetch" href="/assets/js/205.4d437cf2.js"><link rel="prefetch" href="/assets/js/206.074913eb.js"><link rel="prefetch" href="/assets/js/207.f582a2d4.js"><link rel="prefetch" href="/assets/js/208.34c09bd0.js"><link rel="prefetch" href="/assets/js/21.4e3c7f50.js"><link rel="prefetch" href="/assets/js/22.cda475a6.js"><link rel="prefetch" href="/assets/js/23.6677c452.js"><link rel="prefetch" href="/assets/js/24.2e483650.js"><link rel="prefetch" href="/assets/js/25.32b8e5f5.js"><link rel="prefetch" href="/assets/js/26.c63edd69.js"><link rel="prefetch" href="/assets/js/27.6462a4d2.js"><link rel="prefetch" href="/assets/js/28.39745e0d.js"><link rel="prefetch" href="/assets/js/29.3ce79aa0.js"><link rel="prefetch" href="/assets/js/30.c3c07fa8.js"><link rel="prefetch" href="/assets/js/31.b441fe2c.js"><link rel="prefetch" href="/assets/js/32.9d627aa9.js"><link rel="prefetch" href="/assets/js/33.0a131b8b.js"><link rel="prefetch" href="/assets/js/34.e589c02b.js"><link rel="prefetch" href="/assets/js/35.b905220f.js"><link rel="prefetch" href="/assets/js/36.1451544a.js"><link rel="prefetch" href="/assets/js/37.8e64b501.js"><link rel="prefetch" href="/assets/js/38.ac5585b7.js"><link rel="prefetch" href="/assets/js/39.b7d08e4d.js"><link rel="prefetch" href="/assets/js/4.76c12804.js"><link rel="prefetch" href="/assets/js/40.1e627739.js"><link rel="prefetch" href="/assets/js/41.296baa8a.js"><link rel="prefetch" href="/assets/js/42.e762bf53.js"><link rel="prefetch" href="/assets/js/43.0c8916ee.js"><link rel="prefetch" href="/assets/js/44.fb27d611.js"><link rel="prefetch" href="/assets/js/45.a5c6e285.js"><link rel="prefetch" href="/assets/js/46.c00ec7b1.js"><link rel="prefetch" href="/assets/js/47.924f6a63.js"><link rel="prefetch" href="/assets/js/48.da552f4a.js"><link rel="prefetch" href="/assets/js/49.d4b2e85f.js"><link rel="prefetch" href="/assets/js/5.43a1b6a5.js"><link rel="prefetch" href="/assets/js/50.b0cbb861.js"><link rel="prefetch" href="/assets/js/51.d53173dc.js"><link rel="prefetch" href="/assets/js/52.cec22911.js"><link rel="prefetch" href="/assets/js/53.856b0cbd.js"><link rel="prefetch" href="/assets/js/54.a949b4ab.js"><link rel="prefetch" href="/assets/js/55.8b1c4821.js"><link rel="prefetch" href="/assets/js/56.075464d0.js"><link rel="prefetch" href="/assets/js/57.edeffd0c.js"><link rel="prefetch" href="/assets/js/58.f17ca774.js"><link rel="prefetch" href="/assets/js/59.83a509b9.js"><link rel="prefetch" href="/assets/js/6.8c8eb26f.js"><link rel="prefetch" href="/assets/js/60.b2ac681b.js"><link rel="prefetch" href="/assets/js/61.06292aef.js"><link rel="prefetch" href="/assets/js/62.efb1d9ca.js"><link rel="prefetch" href="/assets/js/63.c621ff20.js"><link rel="prefetch" href="/assets/js/64.fd7d869b.js"><link rel="prefetch" href="/assets/js/65.d6e18805.js"><link rel="prefetch" href="/assets/js/66.8e4764ed.js"><link rel="prefetch" href="/assets/js/67.39c5f354.js"><link rel="prefetch" href="/assets/js/68.01631967.js"><link rel="prefetch" href="/assets/js/69.21c55f66.js"><link rel="prefetch" href="/assets/js/7.811e798c.js"><link rel="prefetch" href="/assets/js/70.d93f9ac4.js"><link rel="prefetch" href="/assets/js/71.edff7b32.js"><link rel="prefetch" href="/assets/js/72.58f44a0d.js"><link rel="prefetch" href="/assets/js/73.945f295a.js"><link rel="prefetch" href="/assets/js/74.8ca95c7a.js"><link rel="prefetch" href="/assets/js/75.2bda719a.js"><link rel="prefetch" href="/assets/js/76.160188c6.js"><link rel="prefetch" href="/assets/js/77.13d44a5c.js"><link rel="prefetch" href="/assets/js/78.bc9b4703.js"><link rel="prefetch" href="/assets/js/79.51f0cbe9.js"><link rel="prefetch" href="/assets/js/8.b01cfa02.js"><link rel="prefetch" href="/assets/js/80.d5ee7d7e.js"><link rel="prefetch" href="/assets/js/81.a8cb1bb1.js"><link rel="prefetch" href="/assets/js/82.f2466831.js"><link rel="prefetch" href="/assets/js/83.42e24b89.js"><link rel="prefetch" href="/assets/js/84.f11efdd6.js"><link rel="prefetch" href="/assets/js/85.dfb94ac5.js"><link rel="prefetch" href="/assets/js/86.b722d02e.js"><link rel="prefetch" href="/assets/js/87.50dfa4f1.js"><link rel="prefetch" href="/assets/js/88.1f1be810.js"><link rel="prefetch" href="/assets/js/89.9c872859.js"><link rel="prefetch" href="/assets/js/9.6643bf27.js"><link rel="prefetch" href="/assets/js/90.b45fd9d8.js"><link rel="prefetch" href="/assets/js/91.abf3f5f6.js"><link rel="prefetch" href="/assets/js/92.c4da0439.js"><link rel="prefetch" href="/assets/js/93.ee4705d1.js"><link rel="prefetch" href="/assets/js/94.b5887f79.js"><link rel="prefetch" href="/assets/js/95.1950dbcb.js"><link rel="prefetch" href="/assets/js/96.7fbdc57f.js"><link rel="prefetch" href="/assets/js/97.4e371474.js"><link rel="prefetch" href="/assets/js/98.acbe433f.js"><link rel="prefetch" href="/assets/js/99.358cb13a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.003598ab.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">yx91490的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/java/" class="nav-link">
  Java开发
</a></div><div class="nav-item"><a href="/bigdata/" class="nav-link">
  大数据
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="contactMe" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="contactMe" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/sql/" class="nav-link">
  SQL
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/clang/" class="nav-link">
  C语言
</a></li><li class="dropdown-item"><!----> <a href="/python/" class="nav-link">
  Python
</a></li><li class="dropdown-item"><!----> <a href="/diagram/" class="nav-link">
  图示速查
</a></li><li class="dropdown-item"><!----> <a href="/collection/" class="nav-link">
  资料收藏
</a></li><li class="dropdown-item"><!----> <a href="/cs/" class="nav-link router-link-active">
  计算机科学
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/yx91490" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/yx91490/yx91490.github.io/issues/new" target="_blank" rel="noopener noreferrer" class="nav-link external">
  给我留言
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/java/" class="nav-link">
  Java开发
</a></div><div class="nav-item"><a href="/bigdata/" class="nav-link">
  大数据
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="contactMe" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="contactMe" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/sql/" class="nav-link">
  SQL
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/clang/" class="nav-link">
  C语言
</a></li><li class="dropdown-item"><!----> <a href="/python/" class="nav-link">
  Python
</a></li><li class="dropdown-item"><!----> <a href="/diagram/" class="nav-link">
  图示速查
</a></li><li class="dropdown-item"><!----> <a href="/collection/" class="nav-link">
  资料收藏
</a></li><li class="dropdown-item"><!----> <a href="/cs/" class="nav-link router-link-active">
  计算机科学
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/yx91490" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/yx91490/yx91490.github.io/issues/new" target="_blank" rel="noopener noreferrer" class="nav-link external">
  给我留言
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>计算机科学</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cs/term.html" class="sidebar-link">计算机科学术语</a></li><li><a href="/cs/papers.html" class="sidebar-link">计算机科学论文</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="in-search-of-an-understandable-consensus-algorithm-extended-version"><a href="#in-search-of-an-understandable-consensus-algorithm-extended-version" class="header-anchor">$</a> <a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener noreferrer">In Search of an Understandable Consensus  Algorithm(Extended Version)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h1> <p>Diego Ongaro and John Ousterhout</p> <p>Stanford University</p> <h2 id="abstract"><a href="#abstract" class="header-anchor">$</a> Abstract</h2> <p>Raft is a consensus algorithm for managing a replicated log. It produces a result equivalent to (multi-)Paxos, and it is as efficient as Paxos, but its structure is different from Paxos; this makes Raft more understandable than Paxos and also provides a better foundation for building practical systems. In order to enhance understandability, Raft separates the key elements of consensus, such as leader election, log replication, and safety, and it enforces a stronger degree of coherency to reduce the number of states that must be considered. Results from a user study demonstrate that Raft is easier for students to learn than Paxos. Raft also includes a new mechanism for changing the cluster membership, which uses overlapping majorities to guarantee safety.</p> <h2 id="_1-introduction"><a href="#_1-introduction" class="header-anchor">$</a> 1 Introduction</h2> <p>Consensus algorithms allow a collection of machines to work as a coherent group that can survive the failures of some of its members. Because of this, they play a key role in building reliable largescale software systems.  Paxos [15, 16] has dominated the discussion of consensus algorithms over the last decade: most implementations of consensus are based on Paxos or influenced by it, and Paxos has become the primary vehicle used to teach students about consensus.</p> <p>Unfortunately, Paxos is quite difficult to understand, in spite of numerous attempts to make it more approachable.  Furthermore, its architecture requires complex changes to support practical systems. As a result, both system builders and students struggle with Paxos.</p> <p>After struggling with Paxos ourselves, we set out to find a new consensus algorithm that could provide a better foundation for system building and education. Our approach was unusual in that our primary goal was understandability: could we define a consensus algorithm for practical systems and describe it in a way that is significantly easier to learn than Paxos? Furthermore, we wanted the algorithm to facilitate the development of intuitions that are essential for system builders. It was important not just for the algorithm to work, but for it to be obvious why it works.</p> <p>The result of this work is a consensus algorithm called Raft. In designing Raft we applied specific techniques to improve understandability,including decomposition (Raft separates leader election, log replication, and safety) and state space reduction (relative to Paxos, Raft reduces the degree of nondeterminism and the ways servers can be inconsistent with each other). A user study with 43 students at two universities shows that Raft is significantly easier to understand than Paxos: after learning both algorithms, 33 of these students were able to answer questions about Raft better than questions about Paxos.</p> <p>Raft is similar in many ways to existing consensus algorithms (most notably, Oki and Liskov’s Viewstamped Replication [29, 22]), but it has several novel features:</p> <ul><li><p>Strong leader: Raft uses a stronger form of leadership than other consensus algorithms. For example,  log entries only flow from the leader to other servers.  This simplifies the management of the replicated log  and makes Raft easier to understand.</p></li> <li><p>Leader election: Raft uses randomized timers to  elect leaders. This adds only a small amount of  mechanism to the heartbeats already required for any  consensus algorithm, while resolving conflicts simply and rapidly.</p></li> <li><p>Membership changes: Raft’s mechanism for  changing the set of servers in the cluster uses a new  joint consensus approach where the majorities of  two different configurations overlap during transitions. This allows the cluster to continue operating  normally during configuration changes.</p></li></ul> <p>We believe that Raft is superior to Paxos and other consensus algorithms, both for educational purposes and as a foundation for implementation. It is simpler and more understandable than other algorithms; it is described completely enough to meet the needs of a practical system; it has several opensource implementations and is used by several companies; its safety properties have been formally specified and proven; and its efficiency is comparable to other algorithms.</p> <p>The remainder of the paper introduces the replicated state machine problem (Section 2), discusses the strengths and weaknesses of Paxos (Section 3), describes our general approach to understandability (Section 4), presents the Raft consensus algorithm (Sections 5–8), evaluates Raft (Section 9), and discusses related work (Section 10).</p> <h2 id="_2-replicated-state-machines"><a href="#_2-replicated-state-machines" class="header-anchor">$</a> 2 Replicated state machines</h2> <p><img src="/assets/img/image-20211104232244010.78b07e63.png" alt="image20211104232244010"></p> <blockquote><p>Figure 1: Replicated state machine architecture. The consensus algorithm manages a replicated log containing state machine commands from clients. The state machines process identical sequences of commands from the logs, so they produce the same outputs.</p></blockquote> <p>Consensus algorithms typically arise in the context of replicated state machines [37]. In this approach, state machines on a collection of servers compute identical copies of the same state and can continue operating even if some of the servers are down.</p> <p>Replicated state machines are used to solve a variety of fault tolerance problems in distributed systems. For example, largescale systems that have a single cluster leader, such as GFS [8], HDFS [38], and RAMCloud [33], typically use a separate replicated state machine to manage leader election and store configuration information that must survive leader crashes. Examples of replicated state machines include Chubby [2] and ZooKeeper [11].  Replicated state machines are typically implemented using a replicated log, as shown in Figure 1. Each server stores a log containing a series of commands, which its state machine executes in order. Each log contains the same commands in the same order, so each state machine processes the same sequence of commands. Since the state machines are deterministic, each computes the same state and the same sequence of outputs.</p> <p>Keeping the replicated log consistent is the job of the consensus algorithm. The consensus module on a server receives commands from clients and adds them to its log.  It communicates with the consensus modules on other servers to ensure that every log eventually contains the same requests in the same order, even if some servers fail.  Once commands are properly replicated, each server’s state machine processes them in log order, and the outputs are returned to clients. As a result, the servers appear to form a single, highly reliable state machine.</p> <p>Consensus algorithms for practical systems typically have the following properties:</p> <ul><li>They ensure safety (never returning an incorrect result) under all nonByzantine conditions, including  network delays, partitions, and packet loss, duplication, and reordering.</li> <li>They are fully functional (available) as long as any  majority of the servers are operational and can communicate with each other and with clients. Thus, a  typical cluster of five servers can tolerate the failure  of any two servers. Servers are assumed to fail by  stopping; they may later recover from state on stable  storage and rejoin the cluster.</li> <li>They do not depend on timing to ensure the consistency of the logs: faulty clocks and extreme message  delays can, at worst, cause availability problems.</li> <li>In the common case, a command can complete as  soon as a majority of the cluster has responded to a  single round of remote procedure calls; a minority of  slow servers need not impact overall system performance.</li></ul> <h2 id="_3-what-s-wrong-with-paxos"><a href="#_3-what-s-wrong-with-paxos" class="header-anchor">$</a> 3 What’s wrong with Paxos?</h2> <p>Over the last ten years, Leslie Lamport’s Paxos protocol [15] has become almost synonymous with consensus: it is the protocol most commonly taught in courses, and most implementations of consensus use it as a starting point. Paxos first defines a protocol capable of reaching agreement on a single decision, such as a single replicated log entry. We refer to this subset as singledecree Paxos.  Paxos then combines multiple instances of this protocol to facilitate a series of decisions such as a log (multi-Paxos).  Paxos ensures both safety and liveness, and it supports changes in cluster membership. Its correctness has been proven, and it is efficient in the normal case.</p> <p>Unfortunately, Paxos has two significant drawbacks.  The first drawback is that Paxos is exceptionally difficult to understand. The full explanation [15] is notoriously opaque; few people succeed in understanding it, and only with great effort. As a result, there have been several attempts to explain Paxos in simpler terms [16, 20, 21].  These explanations focus on the singledecree subset, yet they are still challenging. In an informal survey of attendees at NSDI 2012, we found few people who were comfortable with Paxos, even among seasoned researchers.  We struggled with Paxos ourselves; we were not able to understand the complete protocol until after reading several simplified explanations and designing our own alternative protocol, a process that took almost a year.</p> <p>We hypothesize that Paxos’ opaqueness derives from its choice of the singledecree subset as its foundation.  Singledecree Paxos is dense and subtle: it is divided into two stages that do not have simple intuitive explanations and cannot be understood independently. Because of this, it is difficult to develop intuitions about why the singledecree protocol works. The composition rules for multi-Paxos add significant additional complexity and subtlety.  We believe that the overall problem of reaching consensus on multiple decisions (i.e., a log instead of a single entry) can be decomposed in other ways that are more direct and obvious.</p> <p>The second problem with Paxos is that it does not provide a good foundation for building practical implementations. One reason is that there is no widely agreedupon algorithm for multi-Paxos. Lamport’s descriptions are mostly about singledecree Paxos; he sketched possible approaches to multi-Paxos, but many details are missing. There have been several attempts to flesh out and optimize Paxos, such as [26], [39], and [13], but these differ from each other and from Lamport’s sketches. Systems such as Chubby [4] have implemented Paxoslike algorithms, but in most cases their details have not been published.</p> <p>Furthermore, the Paxos architecture is a poor one for building practical systems; this is another consequence of the singledecree decomposition. For example, there is little benefit to choosing a collection of log entries independently and then melding them into a sequential log; this just adds complexity. It is simpler and more efficient to design a system around a log, where new entries are appended sequentially in a constrained order. Another problem is that Paxos uses a symmetric peertopeer approach at its core (though it eventually suggests a weak form of leadership as a performance optimization). This makes sense in a simplified world where only one decision will be made, but few practical systems use this approach. If a series of decisions must be made, it is simpler and faster to first elect a leader, then have the leader coordinate the decisions.</p> <p>As a result, practical systems bear little resemblance to Paxos. Each implementation begins with Paxos, discovers the difficulties in implementing it, and then develops a significantly different architecture. This is timeconsuming and errorprone, and the difficulties of understanding Paxos exacerbate the problem. Paxos’ formulation may be a good one for proving theorems about its correctness, but real implementations are so different from Paxos that the proofs have little value. The following comment from the Chubby implementers is typical:</p> <blockquote><p>There are significant gaps between the description of the Paxos algorithm and the needs of a realworld system. . . . the final system will be based on an unproven protocol [4].</p></blockquote> <p>Because of these problems, we concluded that Paxos does not provide a good foundation either for system building or for education. Given the importance of consensus in largescale software systems, we decided to see if we could design an alternative consensus algorithm with better properties than Paxos. Raft is the result of that experiment.</p> <h2 id="_4-designing-for-understandability"><a href="#_4-designing-for-understandability" class="header-anchor">$</a> 4 Designing for understandability</h2> <p>We had several goals in designing Raft: it must provide a complete and practical foundation for system building, so that it significantly reduces the amount of design work required of developers; it must be safe under all conditions and available under typical operating conditions; and it must be efficient for common operations. But our most important goal—and most difficult challenge—was understandability. It must be possible for a large audience to understand the algorithm comfortably. In addition, it must be possible to develop intuitions about the algorithm, so that system builders can make the extensions that are inevitable in realworld implementations.</p> <p>There were numerous points in the design of Raft where we had to choose among alternative approaches.  In these situations we evaluated the alternatives based on understandability: how hard is it to explain each alternative (for example, how complex is its state space, and does it have subtle implications?), and how easy will it be for a reader to completely understand the approach and its implications?</p> <p>We recognize that there is a high degree of subjectivity in such analysis; nonetheless, we used two techniques that are generally applicable. The first technique is the wellknown approach of problem decomposition: wherever possible, we divided problems into separate pieces that could be solved, explained, and understood relatively independently. For example, in Raft we separated leader election, log replication, safety, and membership changes.</p> <p>Our second approach was to simplify the state space by reducing the number of states to consider, making the system more coherent and eliminating nondeterminism where possible. Specifically, logs are not allowed to have holes, and Raft limits the ways in which logs can become inconsistent with each other. Although in most cases we tried to eliminate nondeterminism, there are some situations where nondeterminism actually improves understandability. In particular, randomized approaches introduce nondeterminism, but they tend to reduce the state space by handling all possible choices in a similar fashion (“choose any; it doesn’t matter”). We used randomization to simplify the Raft leader election algorithm.</p> <h2 id="_5-the-raft-consensus-algorithm"><a href="#_5-the-raft-consensus-algorithm" class="header-anchor">$</a> 5 The Raft consensus algorithm</h2> <p><img src="/assets/img/image-20211104232747561.c96d7fb8.png" alt="image20211104232747561"></p> <blockquote><p>Figure 2: A condensed summary of the Raft consensus algorithm (excluding membership changes and log compaction). The server behavior in the upperleft box is described as a set of rules that trigger independently and repeatedly. Section numbers such as §5.2 indicate where particular features are discussed. A formal specification [31] describes the algorithm more precisely.</p></blockquote> <img src="/assets/img/image-20211104232828729.d23664eb.png" alt="image20211104232828729" style="zoom:50%;"> <blockquote><p>Figure 3: Raft guarantees that each of these properties is true at all times. The section numbers indicate where each property is discussed.</p></blockquote> <p>Raft is an algorithm for managing a replicated log of the form described in Section 2. Figure 2 summarizes the algorithm in condensed form for reference, and Figure 3 lists key properties of the algorithm; the elements of these figures are discussed piecewise over the rest of this section.</p> <p>Raft implements consensus by first electing a distinguished leader, then giving the leader complete responsibility for managing the replicated log. The leader accepts log entries from clients, replicates them on other servers, and tells servers when it is safe to apply log entries to their state machines. Having a leader simplifies the management of the replicated log. For example, the leader can decide where to place new entries in the log without consulting other servers, and data flows in a simple fashion from the leader to other servers. A leader can fail or become disconnected from the other servers, in which case a new leader is elected.</p> <p>Given the leader approach, Raft decomposes the consensus problem into three relatively independent subproblems, which are discussed in the subsections that follow:</p> <ul><li>Leader election: a new leader must be chosen when  an existing leader fails (Section 5.2).</li> <li>Log replication: the leader must accept log entries from clients and replicate them across the cluster,  forcing the other logs to agree with its own (Section 5.3).</li> <li>Safety: the key safety property for Raft is the State  Machine Safety Property in Figure 3: if any server  has applied a particular log entry to its state machine,  then no other server may apply a different command  for the same log index. Section 5.4 describes how  Raft ensures this property; the solution involves an  additional restriction on the election mechanism described in Section 5.2.</li></ul> <p>After presenting the consensus algorithm, this section discusses the issue of availability and the role of timing in the system.</p> <ul><li>5.1 Raft basics</li></ul> <p><img src="/assets/img/image-20211104233011229.c6363666.png" alt="image20211104233011229"></p> <blockquote><p>Figure 4: Server states. Followers only respond to requests from other servers. If a follower receives no communication, it becomes a candidate and initiates an election. A candidate that receives votes from a majority of the full cluster becomes the new leader. Leaders typically operate until they fail.</p></blockquote> <p><img src="/assets/img/image-20211104233112608.87fd9284.png" alt="image20211104233112608"></p> <blockquote><p>Figure 5: Time is divided into terms, and each term begins with an election. After a successful election, a single leader manages the cluster until the end of the term. Some elections fail, in which case the term ends without choosing a leader. The transitions between terms may be observed at different times on different servers.</p></blockquote> <p>A Raft cluster contains several servers; five is a typical number, which allows the system to tolerate two failures.  At any given time each server is in one of three states: leader, follower, or candidate. In normal operation there is exactly one leader and all of the other servers are followers. Followers are passive: they issue no requests on their own but simply respond to requests from leaders and candidates. The leader handles all client requests (if a client contacts a follower, the follower redirects it to the leader). The third state, candidate, is used to elect a new leader as described in Section 5.2. Figure 4 shows the states and their transitions; the transitions are discussed below.</p> <p>Raft divides time into terms of arbitrary length, as shown in Figure 5. Terms are numbered with consecutive integers. Each term begins with an election, in which one or more candidates attempt to become leader as described in Section 5.2. If a candidate wins the election, then it serves as leader for the rest of the term. In some situations an election will result in a split vote. In this case the term will end with no leader; a new term (with a new election) will begin shortly. Raft ensures that there is at most one leader in a given term.</p> <p>Different servers may observe the transitions between terms at different times, and in some situations a server may not observe an election or even entire terms. Terms act as a logical clock [14] in Raft, and they allow servers to detect obsolete information such as stale leaders. Each server stores a current term number, which increases monotonically over time. Current terms are exchanged whenever servers communicate; if one server’s current term is smaller than the other’s, then it updates its current term to the larger value. If a candidate or leader discovers that its term is out of date, it immediately reverts to follower state. If a server receives a request with a stale term number, it rejects the request.</p> <p>Raft servers communicate using remote procedure calls (RPCs), and the basic consensus algorithm requires only two types of RPCs. RequestVote RPCs are initiated by candidates during elections (Section 5.2), and AppendEntries RPCs are initiated by leaders to replicate log entries and to provide a form of heartbeat (Section 5.3). Section 7 adds a third RPC for transferring snapshots between servers. Servers retry RPCs if they do not receive a response in a timely manner, and they issue RPCs in parallel for best performance.</p> <ul><li>5.2 Leader election</li></ul> <p><img src="/assets/img/image-20211104233231178.3bc9f196.png" alt="image20211104233231178"></p> <blockquote><p>Figure 6: Logs are composed of entries, which are numbered sequentially. Each entry contains the term in which it was created (the number in each box) and a command for the state machine. An entry is considered committed if it is safe for that entry to be applied to state machines.</p></blockquote> <p>Raft uses a heartbeat mechanism to trigger leader election. When servers start up, they begin as followers. A server remains in follower state as long as it receives valid RPCs from a leader or candidate. Leaders send periodic heartbeats (AppendEntries RPCs that carry no log entries) to all followers in order to maintain their authority. If a follower receives no communication over a period of time called the election timeout, then it assumes there is no viable leader and begins an election to choose a new leader.</p> <p>To begin an election, a follower increments its current term and transitions to candidate state. It then votes for itself and issues RequestVote RPCs in parallel to each of the other servers in the cluster. A candidate continues in this state until one of three things happens: (a) it wins the election, (b) another server establishes itself as leader, or (c) a period of time goes by with no winner. These outcomes are discussed separately in the paragraphs below.</p> <p>A candidate wins an election if it receives votes from a majority of the servers in the full cluster for the same term. Each server will vote for at most one candidate in a given term, on a firstcomefirstserved basis (note: Section 5.4 adds an additional restriction on votes). The majority rule ensures that at most one candidate can win the election for a particular term (the Election Safety Property in Figure 3). Once a candidate wins an election, it becomes leader. It then sends heartbeat messages to all of the other servers to establish its authority and prevent new elections.</p> <p>While waiting for votes, a candidate may receive an AppendEntries RPC from another server claiming to be leader. If the leader’s term (included in its RPC) is at least as large as the candidate’s current term, then the candidate recognizes the leader as legitimate and returns to follower state. If the term in the RPC is smaller than the candidate’s current term, then the candidate rejects the RPC and continues in candidate state.</p> <p>The third possible outcome is that a candidate neither wins nor loses the election: if many followers become candidates at the same time, votes could be split so that no candidate obtains a majority. When this happens, each candidate will time out and start a new election by incrementing its term and initiating another round of RequestVote RPCs. However, without extra measures split votes could repeat indefinitely.</p> <p>Raft uses randomized election timeouts to ensure that split votes are rare and that they are resolved quickly. To prevent split votes in the first place, election timeouts are chosen randomly from a fixed interval (e.g., 150–300ms).  This spreads out the servers so that in most cases only a single server will time out; it wins the election and sends heartbeats before any other servers time out. The same mechanism is used to handle split votes. Each candidate restarts its randomized election timeout at the start of an election, and it waits for that timeout to elapse before starting the next election; this reduces the likelihood of another split vote in the new election. Section 9.3 shows that this approach elects a leader rapidly.</p> <p>Elections are an example of how understandability guided our choice between design alternatives. Initially we planned to use a ranking system: each candidate was assigned a unique rank, which was used to select between competing candidates. If a candidate discovered another candidate with higher rank, it would return to follower state so that the higher ranking candidate could more easily win the next election. We found that this approach created subtle issues around availability (a lowerranked server might need to time out and become a candidate again if a higherranked server fails, but if it does so too soon, it can reset progress towards electing a leader). We made adjustments to the algorithm several times, but after each adjustment new corner cases appeared. Eventually we concluded that the randomized retry approach is more obvious and understandable.</p> <h3 id="_5-3-log-replication"><a href="#_5-3-log-replication" class="header-anchor">$</a> 5.3 Log replication</h3> <p><img src="/assets/img/image-20211104233532422.6e978f03.png" alt="image20211104233532422"></p> <blockquote><p>Figure 7: When the leader at the top comes to power, it is possible that any of scenarios (a–f) could occur in follower logs. Each box represents one log entry; the number in the box is its term. A follower may be missing entries (a–b), may have extra uncommitted entries (c–d), or both (e–f). For example, scenario (f) could occur if that server was the leader for term 2, added several entries to its log, then crashed before committing any of them; it restarted quickly, became leader for term 3, and added a few more entries to its log; before any of the entries in either term 2 or term 3 were committed, the server crashed again and remained down for several terms.</p></blockquote> <p>Once a leader has been elected, it begins servicing client requests. Each client request contains a command to be executed by the replicated state machines. The leader appends the command to its log as a new entry, then issues AppendEntries RPCs in parallel to each of the other servers to replicate the entry. When the entry has been safely replicated (as described below), the leader applies the entry to its state machine and returns the result of that execution to the client. If followers crash or run slowly, or if network packets are lost, the leader retries AppendEntries RPCs indefinitely (even after it has responded to the client) until all followers eventually store all log entries.</p> <p>Logs are organized as shown in Figure 6. Each log entry stores a state machine command along with the term number when the entry was received by the leader. The term numbers in log entries are used to detect inconsistencies between logs and to ensure some of the properties in Figure 3. Each log entry also has an integer index identifying its position in the log.</p> <p>The leader decides when it is safe to apply a log entry to the state machines; such an entry is called committed. Raft guarantees that committed entries are durable and will eventually be executed by all of the available state machines. A log entry is committed once the leader that created the entry has replicated it on a majority of the servers (e.g., entry 7 in Figure 6). This also commits all preceding entries in the leader’s log, including entries created by previous leaders. Section 5.4 discusses some subtleties when applying this rule after leader changes, and it also shows that this definition of commitment is safe. The leader keeps track of the highest index it knows to be committed, and it includes that index in future AppendEntries RPCs (including heartbeats) so that the other servers eventually find out. Once a follower learns that a log entry is committed, it applies the entry to its local state machine (in log order).</p> <p>We designed the Raft log mechanism to maintain a high level of coherency between the logs on different servers.  Not only does this simplify the system’s behavior and make it more predictable, but it is an important component of ensuring safety. Raft maintains the following properties, which together constitute the Log Matching Property
in Figure 3:</p> <ul><li>If two entries in different logs have the same index  and term, then they store the same command.</li> <li>If two entries in different logs have the same index  and term, then the logs are identical in all preceding  entries.</li></ul> <p>The first property follows from the fact that a leader creates at most one entry with a given log index in a given term, and log entries never change their position in the log. The second property is guaranteed by a simple consistency check performed by AppendEntries. When sending an AppendEntries RPC, the leader includes the index and term of the entry in its log that immediately precedes the new entries. If the follower does not find an entry in its log with the same index and term, then it refuses the new entries. The consistency check acts as an induction step: the initial empty state of the logs satisfies the Log Matching Property, and the consistency check preserves the Log Matching Property whenever logs are extended.  As a result, whenever AppendEntries returns successfully, the leader knows that the follower’s log is identical to its own log up through the new entries.</p> <p>During normal operation, the logs of the leader and followers stay consistent, so the AppendEntries consistency check never fails. However, leader crashes can leave the logs inconsistent (the old leader may not have fully replicated all of the entries in its log). These inconsistencies can compound over a series of leader and follower crashes. Figure 7 illustrates the ways in which followers’ logs may differ from that of a new leader. A follower may be missing entries that are present on the leader, it may have extra entries that are not present on the leader, or both. Missing and extraneous entries in a log may span multiple terms.</p> <p>In Raft, the leader handles inconsistencies by forcing the followers’ logs to duplicate its own. This means that conflicting entries in follower logs will be overwritten with entries from the leader’s log. Section 5.4 will show that this is safe when coupled with one more restriction.</p> <p>To bring a follower’s log into consistency with its own, the leader must find the latest log entry where the two logs agree, delete any entries in the follower’s log after that point, and send the follower all of the leader’s entries after that point. All of these actions happen in response to the consistency check performed by AppendEntries RPCs. The leader maintains a nextIndex for each follower, which is the index of the next log entry the leader will send to that follower. When a leader first comes to power,</p> <p>it initializes all nextIndex values to the index just after the last one in its log (11 in Figure 7). If a follower’s log is inconsistent with the leader’s, the AppendEntries consistency check will fail in the next AppendEntries RPC. After a rejection, the leader decrements nextIndex and retries the AppendEntries RPC. Eventually nextIndex will reach a point where the leader and follower logs match. When this happens, AppendEntries will succeed, which removes any conflicting entries in the follower’s log and appends entries from the leader’s log (if any). Once AppendEntries succeeds, the follower’s log is consistent with the leader’s, and it will remain that way for the rest of the term.</p> <p>If desired, the protocol can be optimized to reduce the number of rejected AppendEntries RPCs. For example, when rejecting an AppendEntries request, the follower can include the term of the conflicting entry and the first index it stores for that term. With this information, the leader can decrement nextIndex to bypass all of the conflicting entries in that term; one AppendEntries RPC will be required for each term with conflicting entries, rather than one RPC per entry. In practice, we doubt this optimization is necessary, since failures happen infrequently and it is unlikely that there will be many inconsistent entries.</p> <p>With this mechanism, a leader does not need to take any special actions to restore log consistency when it comes to power. It just begins normal operation, and the logs automatically converge in response to failures of the AppendEntries consistency check. A leader never overwrites or deletes entries in its own log (the Leader AppendOnly Property in Figure 3).</p> <p>This log replication mechanism exhibits the desirable consensus properties described in Section 2: Raft can accept, replicate, and apply new log entries as long as a majority of the servers are up; in the normal case a new entry can be replicated with a single round of RPCs to a majority of the cluster; and a single slow follower will not impact performance.</p> <h3 id="_5-4-safety"><a href="#_5-4-safety" class="header-anchor">$</a> 5.4 Safety</h3> <p>The previous sections described how Raft elects leaders and replicates log entries. However, the mechanisms described so far are not quite sufficient to ensure that each state machine executes exactly the same commands in the same order. For example, a follower might be unavailable while the leader commits several log entries, then it could be elected leader and overwrite these entries with new ones; as a result, different state machines might execute different command sequences.</p> <p>This section completes the Raft algorithm by adding a restriction on which servers may be elected leader. The restriction ensures that the leader for any given term contains all of the entries committed in previous terms (the Leader Completeness Property from Figure 3). Given the election restriction, we then make the rules for commitment more precise. Finally, we present a proof sketch for the Leader Completeness Property and show how it leads to correct behavior of the replicated state machine.</p> <h4 id="_5-4-1-election-restriction"><a href="#_5-4-1-election-restriction" class="header-anchor">$</a> 5.4.1 Election restriction</h4> <p><img src="/assets/img/image-20211104233737401.968dfe13.png" alt="image20211104233737401"></p> <blockquote><p>Figure 8: A time sequence showing why a leader cannot determine commitment using log entries from older terms. In (a) S1 is leader and partially replicates the log entry at index \2. In (b) S1 crashes; S5 is elected leader for term 3 with votes from S3, S4, and itself, and accepts a different entry at log index 2. In (c) S5 crashes; S1 restarts, is elected leader, and continues replication. At this point, the log entry from term 2 has been replicated on a majority of the servers, but it is not committed. If S1 crashes as in (d), S5 could be elected leader (with votes from S2, S3, and S4) and overwrite the entry with its own entry from term 3. However, if S1 replicates an entry from its current term on a majority of the servers before crashing, as in (e), then this entry is committed (S5 cannot win an election). At this point all preceding entries in the log are committed as well.</p></blockquote> <p>In any leaderbased consensus algorithm, the leader must eventually store all of the committed log entries. In some consensus algorithms, such as Viewstamped Replication [22], a leader can be elected even if it doesn’t initially contain all of the committed entries. These algorithms contain additional mechanisms to identify the missing entries and transmit them to the new leader, either during the election process or shortly afterwards. Unfortunately, this results in considerable additional mechanism and complexity.</p> <p>Raft uses a simpler approach where it guarantees that all the committed entries from previous terms are present on each new leader from the moment of its election, without the need to transfer those entries to the leader. This means that log entries only flow in one direction, from leaders to followers, and leaders never overwrite existing entries in their logs.  Raft uses the voting process to prevent a candidate from winning an election unless its log contains all committed entries. A candidate must contact a majority of the cluster in order to be elected, which means that every committed entry must be present in at least one of those servers. If the candidate’s log is at least as uptodate as any other log in that majority (where “uptodate” is defined precisely below), then it will hold all the committed entries. The RequestVote RPC implements this restriction: the RPC includes information about the candidate’s log, and the voter denies its vote if its own log is more uptodate than that of the candidate.</p> <p>Raft determines which of two logs is more uptodate by comparing the index and term of the last entries in the logs. If the logs have last entries with different terms, then the log with the later term is more uptodate. If the logs end with the same term, then whichever log is longer is more uptodate.</p> <p>####5.4.2 Committing entries from previous terms</p> <p><img src="/assets/img/image-20211104233832941.96ea1f0a.png" alt="image20211104233832941"></p> <blockquote><p>Figure 9: If S1 (leader for term T) commits a new log entry from its term, and S5 is elected leader for a later term U, then there must be at least one server (S3) that accepted the log entry and also voted for S5.</p></blockquote> <p>As described in Section 5.3, a leader knows that an entry from its current term is committed once that entry is stored on a majority of the servers. If a leader crashes before committing an entry, future leaders will attempt to finish replicating the entry. However, a leader cannot immediately conclude that an entry from a previous term is committed once it is stored on a majority of servers. Figure 8 illustrates a situation where an old log entry is stored on a majority of servers, yet can still be overwritten by a future leader.</p> <p>To eliminate problems like the one in Figure 8, Raft never commits log entries from previous terms by counting replicas. Only log entries from the leader’s current term are committed by counting replicas; once an entry from the current term has been committed in this way, then all prior entries are committed indirectly because of the Log Matching Property. There are some situations where a leader could safely conclude that an older log entry is committed (for example, if that entry is stored on every server), but Raft takes a more conservative approach for simplicity.</p> <p>Raft incurs this extra complexity in the commitment rules because log entries retain their original term numbers when a leader replicates entries from previous terms. In other consensus algorithms, if a new leader rereplicates entries from prior “terms,” it must do so with its new “term number.” Raft’s approach makes it easier to reason about log entries, since they maintain the same term number over time and across logs. In addition, new leaders in Raft send fewer log entries from previous terms than in other algorithms (other algorithms must send redundant log entries to renumber them before they can be committed).</p> <p>####5.4.3 Safety argument</p> <p>Given the complete Raft algorithm, we can now argue more precisely that the Leader Completeness Property holds (this argument is based on the safety proof; see Section 9.2). We assume that the Leader Completeness Property does not hold, then we prove a contradiction.  Suppose the leader for term T (leaderT) commits a log entry from its term, but that log entry is not stored by the leader of some future term. Consider the smallest term U
&gt; T whose leader (leaderU) does not store the entry.</p> <ol><li><p>The committed entry must have been absent from   leaderU’s log at the time of its election (leaders never   delete or overwrite entries).</p></li> <li><p>leaderT replicated the entry on a majority of the cluster, and leaderU received votes from a majority of   the cluster. Thus, at least one server (“the voter”)   both accepted the entry from leaderT and voted for leaderU, as shown in Figure 9. The voter is key to   reaching a contradiction.</p></li> <li><p>The voter must have accepted the committed entry   from leaderT before voting for leaderU; otherwise it   would have rejected the AppendEntries request from   leaderT (its current term would have been higher than   T).</p></li> <li><p>The voter still stored the entry when it voted for   leaderU, since every intervening leader contained the   entry (by assumption), leaders never remove entries,   and followers only remove entries if they conflict   with the leader.</p></li> <li><p>The voter granted its vote to leaderU, so leaderU’s   log must have been as uptodate as the voter’s. This   leads to one of two contradictions.</p></li> <li><p>First, if the voter and leaderU shared the same last   log term, then leaderU’s log must have been at least   as long as the voter’s, so its log contained every entry   in the voter’s log. This is a contradiction, since the   voter contained the committed entry and leaderU was   assumed not to.</p></li> <li><p>Otherwise, leaderU’s last log term must have been   larger than the voter’s. Moreover, it was larger than   T, since the voter’s last log term was at least T (it contains the committed entry from term T). The earlier   leader that created leaderU’s last log entry must have   contained the committed entry in its log (by assumption). Then, by the Log Matching Property, leaderU’s   log must also contain the committed entry, which is   a contradiction.</p></li> <li><p>This completes the contradiction. Thus, the leaders   of all terms greater than T must contain all entries   from term T that are committed in term T.</p></li> <li><p>The Log Matching Property guarantees that future   leaders will also contain entries that are committed   indirectly, such as index 2 in Figure 8(d).</p></li></ol> <p>Given the Leader Completeness Property, we can prove the State Machine Safety Property from Figure 3, which states that if a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index. At the time a server applies a log entry to its state machine, its log must be identical to the leader’s log up through that entry and the entry must be committed. Now consider the lowest term in which any server applies a given log index; the Log Completeness Property guarantees that the leaders for all higher terms will store that same log entry, so servers that apply the index in later terms will apply the same value.  Thus, the State Machine Safety Property holds.</p> <p>Finally, Raft requires servers to apply entries in log index order. Combined with the State Machine Safety Property, this means that all servers will apply exactly the same set of log entries to their state machines, in the same order.</p> <h3 id="_5-5-follower-and-candidate-crashes"><a href="#_5-5-follower-and-candidate-crashes" class="header-anchor">$</a> 5.5 Follower and candidate crashes</h3> <p>Until this point we have focused on leader failures. Follower and candidate crashes are much simpler to handle than leader crashes, and they are both handled in the same way. If a follower or candidate crashes, then future RequestVote and AppendEntries RPCs sent to it will fail. Raft handles these failures by retrying indefinitely; if the crashed server restarts, then the RPC will complete successfully. If a server crashes after completing an RPC but before responding, then it will receive the same RPC again after it restarts. Raft RPCs are idempotent, so this causes no harm. For example, if a follower receives an AppendEntries request that includes log entries already present in its log, it ignores those entries in the new request.</p> <h3 id="_5-6-timing-and-availability"><a href="#_5-6-timing-and-availability" class="header-anchor">$</a> 5.6 Timing and availability</h3> <p>One of our requirements for Raft is that safety must not depend on timing: the system must not produce incorrect results just because some event happens more quickly or slowly than expected. However, availability (the ability of the system to respond to clients in a timely manner) must inevitably depend on timing. For example, if message exchanges take longer than the typical time between server crashes, candidates will not stay up long enough to win an election; without a steady leader, Raft cannot make progress.</p> <p>Leader election is the aspect of Raft where timing is most critical. Raft will be able to elect and maintain a steady leader as long as the system satisfies the following timing requirement:</p> <div class="language- extra-class"><pre class="language-text"><code>broadcastTime ≪ electionTimeout ≪ MTBF
</code></pre></div><p>In this inequality broadcastTime is the average time it takes a server to send RPCs in parallel to every server in the cluster and receive their responses; electionTimeout is the election timeout described in Section 5.2; and MTBF is the average time between failures for a single server. The broadcast time should be an order of magnitude less than the election timeout so that leaders can reliably send the heartbeat messages required to keep followers from starting elections; given the randomized approach used for election timeouts, this inequality also makes split votes unlikely. The election timeout should be a few orders of magnitude less than MTBF so that the system makes steady progress. When the leader crashes, the system will be unavailable for roughly the election timeout; we would like this to represent only a small fraction of overall time.</p> <p>The broadcast time and MTBF are properties of the underlying system, while the election timeout is something we must choose. Raft’s RPCs typically require the recipient to persist information to stable storage, so the broadcast time may range from 0.5ms to 20ms, depending on storage technology. As a result, the election timeout islikely to be somewhere between 10ms and 500ms. Typical server MTBFs are several months or more, which easily satisfies the timing requirement.</p> <h2 id="_6-cluster-membership-changes"><a href="#_6-cluster-membership-changes" class="header-anchor">$</a> 6 Cluster membership changes</h2> <p><img src="/assets/img/image-20211104234829476.5666ee77.png" alt="image20211104234829476"></p> <blockquote><p>Figure 11: Timeline for a configuration change. Dashed lines  show configuration entries that have been created but not committed, and solid lines show the latest committed configuration entry. The leader first creates the Cold,new configuration entry in its log and commits it to Cold,new (a majority of Cold and a majority of Cnew). Then it creates the Cnew entry and commits it to a majority of Cnew. There is no point in time in which Cold and Cnew can both make decisions independently.</p></blockquote> <p>Up until now we have assumed that the cluster configuration (the set of servers participating in the consensus algorithm) is fixed. In practice, it will occasionally be necessary to change the configuration, for example to replace servers when they fail or to change the degree of replication. Although this can be done by taking the entire cluster offline, updating configuration files, and then restarting the cluster, this would leave the cluster unavailable during the changeover. In addition, if there are any manual steps, they risk operator error. In order to avoid these issues, we decided to automate configuration changes and incorporate them into the Raft consensus algorithm.</p> <p>For the configuration change mechanism to be safe, there must be no point during the transition where it is possible for two leaders to be elected for the same term. Unfortunately, any approach where servers switch directly from the old configuration to the new configuration is unsafe. It isn’t possible to atomically switch all of the servers at once, so the cluster can potentially split into two independent majorities during the transition (see Figure 10).</p> <p>In order to ensure safety, configuration changes must use a twophase approach. There are a variety of ways to implement the two phases. For example, some systems (e.g., [22]) use the first phase to disable the old configuration so it cannot process client requests; then the second phase enables the new configuration. In Raft the cluster first switches to a transitional configuration we call joint consensus; once the joint consensus has been committed, the system then transitions to the new configuration. The joint consensus combines both the old and new configurations:</p> <ul><li>Log entries are replicated to all servers in both configurations.</li> <li>Any server from either configuration may serve as  leader.</li> <li>Agreement (for elections and entry commitment) requires separate majorities from both the old and new  configurations.Agreement (for elections and entry commitment) requires separate majorities from both the old and new  configurations.</li></ul> <p>The joint consensus allows individual servers to transition between configurations at different times without compromising safety. Furthermore, joint consensus allows the cluster to continue servicing client requests throughout the configuration change.</p> <p>Cluster configurations are stored and communicated using special entries in the replicated log; Figure 11 illustrates the configuration change process. When the leader receives a request to change the configuration from Cold to Cnew, it stores the configuration for joint consensus (Cold,new in the figure) as a log entry and replicates that entry using the mechanisms described previously. Once a given server adds the new configuration entry to its log, it uses that configuration for all future decisions (a server always uses the latest configuration in its log, regardless of whether the entry is committed). This means that the leader will use the rules of Cold,new to determine when the log entry for Cold,new is committed. If the leader crashes, a new leader may be chosen under either Cold or Cold,new, depending on whether the winning candidate has received Cold,new. In any case, Cnew cannot make unilateral decisions during this period.</p> <p>OnceCold,new has been committed, neitherCold norCnew can make decisions without approval of the other, and the Leader Completeness Property ensures that only servers with the Cold,new log entry can be elected as leader. It is now safe for the leader to create a log entry describing
Cnew and replicate it to the cluster. Again, this configuration will take effect on each server as soon as it is seen. When the new configuration has been committed under the rules of Cnew, the old configuration is irrelevant and servers not in the new configuration can be shut down. As shown in Figure 11, there is no time when Cold and Cnew can both make unilateral decisions; this guarantees safety.</p> <p>There are three more issues to address for reconfiguration. The first issue is that new servers may not initially store any log entries. If they are added to the cluster in this state, it could take quite a while for them to catch up, during which time it might not be possible to commit new log entries. In order to avoid availability gaps, Raft introduces an additional phase before the configuration change, in which the new servers join the cluster as nonvoting members (the leader replicates log entries to them, but they are not considered for majorities). Once the new servers have caught up with the rest of the cluster, the reconfiguration can proceed as described above.</p> <p>The second issue is that the cluster leader may not be part of the new configuration. In this case, the leader steps down (returns to follower state) once it has committed the Cnew log entry. This means that there will be a period of time (while it is committingCnew) when the leader is managing a cluster that does not include itself; it replicates log entries but does not count itself in majorities. The leader transition occurs when Cnew is committed because this is the first point when the new configuration can operate independently (it will always be possible to choose a leader from Cnew). Before this point, it may be the case that only a server from Cold can be elected leader.</p> <p>The third issue is that removed servers (those not in Cnew) can disrupt the cluster. These servers will not receive heartbeats, so they will time out and start new elections. They will then send RequestVote RPCs with new term numbers, and this will cause the current leader to revert to follower state. A new leader will eventually be elected, but the removed servers will time out again and the process will repeat, resulting in poor availability.</p> <p>To prevent this problem, servers disregard RequestVote RPCs when they believe a current leader exists. Specifically, if a server receives a RequestVote RPC within the minimum election timeout of hearing from a current leader, it does not update its term or grant its vote.  This does not affect normal elections, where each server waits at least a minimum election timeout before starting an election. However, it helps avoid disruptions from removed servers: if a leader is able to get heartbeats to its cluster, then it will not be deposed by larger term numbers.</p> <h2 id="_7-log-compaction"><a href="#_7-log-compaction" class="header-anchor">$</a> 7 Log compaction</h2> <p><img src="/assets/img/image-20211104234937062.82d8d357.png" alt="image20211104234937062"></p> <blockquote><p>Figure 12: A server replaces the committed entries in its log  (indexes 1 through 5) with a new snapshot, which stores just the current state (variables x and y in this example). The snapshot’s last included index and term serve to position the snapshot in the log preceding entry 6.</p></blockquote> <p>Raft’s log grows during normal operation to incorporate more client requests, but in a practical system, it cannot grow without bound. As the log grows longer, it occupies more space and takes more time to replay. This will eventually cause availability problems without some mechanism to discard obsolete information that has accumulated in the log.</p> <p>Snapshotting is the simplest approach to compaction.  In snapshotting, the entire current system state is written to a snapshot on stable storage, then the entire log up to that point is discarded. Snapshotting is used in Chubby and ZooKeeper, and the remainder of this section describes snapshotting in Raft.</p> <p>Incremental approaches to compaction, such as log cleaning [36] and logstructured merge trees [30, 5], are also possible. These operate on a fraction of the data at once, so they spread the load of compaction more evenly over time. They first select a region of data that has accumulated many deleted and overwritten objects, then they rewrite the live objects from that region more compactly and free the region. This requires significant additional mechanism and complexity compared to snapshotting, which simplifies the problem by always operating on the entire data set. While log cleaning would require modifications to Raft, state machines can implement LSM trees using the same interface as snapshotting.</p> <p>Figure 12 shows the basic idea of snapshotting in Raft.  Each server takes snapshots independently, covering just the committed entries in its log. Most of the work consists of the state machine writing its current state to the snapshot. Raft also includes a small amount of metadata in the snapshot: the last included index is the index of the last entry in the log that the snapshot replaces (the last entry the state machine had applied), and the last included term is the term of this entry. These are preserved to support the AppendEntries consistency check for the first log entry following the snapshot, since that entry needs a previous log index and term. To enable cluster membership changes (Section 6), the snapshot also includes the latest configuration in the log as of last included index. Once a server completes writing a snapshot, it may delete all log entries up through the last included index, as well as any prior snapshot.</p> <p>Although servers normally take snapshots independently, the leader must occasionally send snapshots to followers that lag behind. This happens when the leader has already discarded the next log entry that it needs to send to a follower. Fortunately, this situation is unlikely in normal operation: a follower that has kept up with the leader would already have this entry. However, an exceptionally slow follower or a new server joining the cluster (Section 6) would not. The way to bring such a follower uptodate is for the leader to send it a snapshot over the network.</p> <p><img src="/assets/img/image-20211104235032877.15693abb.png" alt="image20211104235032877"></p> <p>The leader uses a new RPC called InstallSnapshot to send snapshots to followers that are too far behind; see Figure 13. When a follower receives a snapshot with this RPC, it must decide what to do with its existing log entries. Usually the snapshot will contain new information not already in the recipient’s log. In this case, the follower discards its entire log; it is all superseded by the snapshot and may possibly have uncommitted entries that conflict with the snapshot. If instead the follower receives a snapshot that describes a prefix of its log (due to retransmission or by mistake), then log entries covered by the snapshot are deleted but entries following the snapshot are still valid and must be retained.</p> <p>This snapshotting approach departs from Raft’s strong leader principle, since followers can take snapshots without the knowledge of the leader. However, we think this departure is justified. While having a leader helps avoid conflicting decisions in reaching consensus, consensus has already been reached when snapshotting, so no decisions conflict. Data still only flows from leaders to followers, just followers can now reorganize their data.</p> <p>We considered an alternative leaderbased approach in which only the leader would create a snapshot, then it would send this snapshot to each of its followers. However, this has two disadvantages. First, sending the snapshot to each follower would waste network bandwidth and slow the snapshotting process. Each follower already has the information needed to produce its own snapshots, and it is typically much cheaper for a server to produce a snapshot from its local state than it is to send and receive one over the network. Second, the leader’s implementation would be more complex. For example, the leader would need to send snapshots to followers in parallel with replicating new log entries to them, so as not to block new client requests.</p> <p>There are two more issues that impact snapshotting performance. First, servers must decide when to snapshot. If a server snapshots too often, it wastes disk bandwidth and energy; if it snapshots too infrequently, it risks exhausting its storage capacity, and it increases the time required to replay the log during restarts. One simple strategy is to take a snapshot when the log reaches a fixed size in bytes. If this size is set to be significantly larger than the expected size of a snapshot, then the disk bandwidth overhead for snapshotting will be small.</p> <p>The second performance issue is that writing a snapshot can take a significant amount of time, and we do not want this to delay normal operations. The solution is to use copyonwrite techniques so that new updates can be accepted without impacting the snapshot being written. For example, state machines built with functional data structures naturally support this. Alternatively, the operating system’s copyonwrite support (e.g., fork on Linux) can be used to create an inmemory snapshot of the entire state machine (our implementation uses this approach).</p> <h2 id="_8-client-interaction"><a href="#_8-client-interaction" class="header-anchor">$</a> 8 Client interaction</h2> <p>This section describes how clients interact with Raft, including how clients find the cluster leader and how Raft supports linearizable semantics [10]. These issues apply to all consensusbased systems, and Raft’s solutions are similar to other systems.</p> <p>Clients of Raft send all of their requests to the leader.  When a client first starts up, it connects to a randomlychosen server. If the client’s first choice is not the leader, that server will reject the client’s request and supply information about the most recent leader it has heard from (AppendEntries requests include the network address of the leader). If the leader crashes, client requests will time out; clients then try again with randomlychosen servers.</p> <p>Our goal for Raft is to implement linearizable semantics (each operation appears to execute instantaneously, exactly once, at some point between its invocation and its response). However, as described so far Raft can execute a command multiple times: for example, if the leader crashes after committing the log entry but before responding to the client, the client will retry the command with a new leader, causing it to be executed a second time. The solution is for clients to assign unique serial numbers to every command. Then, the state machine tracks the latest serial number processed for each client, along with the associated response. If it receives a command whose serial number has already been executed, it responds immediately without reexecuting the request.</p> <p>Read-only operations can be handled without writing anything into the log. However, with no additional measures, this would run the risk of returning stale data, since the leader responding to the request might have been superseded by a newer leader of which it is unaware. Linearizable reads must not return stale data, and Raft needs two extra precautions to guarantee this without using the log. First, a leader must have the latest information on which entries are committed. The Leader Completeness Property guarantees that a leader has all committed entries, but at the start of its term, it may not know which those are. To find out, it needs to commit an entry from its term. Raft handles this by having each leader commit a blank noop entry into the log at the start of its term. Second, a leader must check whether it has been deposed before processing a readonly request (its information may be stale if a more recent leader has been elected).  Raft handles this by having the leader exchange heartbeat messages with a majority of the cluster before responding to readonly requests. Alternatively, the leader could rely on the heartbeat mechanism to provide a form of lease [9], but this would rely on timing for safety (it assumes bounded clock skew).</p> <h2 id="_9-implementation-and-evaluation"><a href="#_9-implementation-and-evaluation" class="header-anchor">$</a> 9 Implementation and evaluation</h2> <p>We have implemented Raft as part of a replicated state machine that stores configuration information for RAMCloud [33] and assists in failover of the RAMCloud coordinator. The Raft implementation contains roughly 2000 lines of C++ code, not including tests, comments, or blank lines. The source code is freely available [23]. There are also about 25 independent thirdparty open source implementations [34] of Raft in various stages of development, based on drafts of this paper. Also, various companies are deploying Raftbased systems [34].  The remainder of this section evaluates Raft using three criteria: understandability, correctness, and performance.</p> <h3 id="_9-1-understandability"><a href="#_9-1-understandability" class="header-anchor">$</a> 9.1 Understandability</h3> <p><img src="/assets/img/image-20211104235252365.7c168af3.png" alt="image20211104235252365"></p> <p>To measure Raft’s understandability relative to Paxos, we conducted an experimental study using upperlevel undergraduate and graduate students in an Advanced Operating Systems course at Stanford University and a Distributed Computing course at U.C. Berkeley. We recorded a video lecture of Raft and another of Paxos, and created corresponding quizzes. The Raft lecture covered the content of this paper except for log compaction; the Paxos lecture covered enough material to create an equivalent replicated state machine, including singledecree Paxos, multi-decree Paxos, reconfiguration, and a few optimizations needed in practice (such as leader election). The quizzes tested basic understanding of the algorithms and also required students to reason about corner cases. Each student watched one video, took the corresponding quiz, watched the second video, and took the second quiz.  About half of the participants did the Paxos portion first and the other half did the Raft portion first in order to account for both individual differences in performance and experience gained from the first portion of the study.  We compared participants’ scores on each quiz to determine whether participants showed a better understanding of Raft.</p> <p>We tried to make the comparison between Paxos and Raft as fair as possible. The experiment favored Paxos in two ways: 15 of the 43 participants reported having some prior experience with Paxos, and the Paxos video is 14% longer than the Raft video. As summarized in Table 1, we have taken steps to mitigate potential sources of bias. All of our materials are available for review [28, 31].</p> <p>On average, participants scored 4.9 points higher on the Raft quiz than on the Paxos quiz (out of a possible 60 points, the mean Raft score was 25.7 and the mean Paxos score was 20.8); Figure 14 shows their individual scores.  A paired ttest states that, with 95% confidence, the true distribution of Raft scores has a mean at least 2.5 points larger than the true distribution of Paxos scores.</p> <p>We also created a linear regression model that predicts a new student’s quiz scores based on three factors: which quiz they took, their degree of prior Paxos experience, and the order in which they learned the algorithms. The model predicts that the choice of quiz produces a 12.5point difference in favor of Raft. This is significantly higher than the observed difference of 4.9 points, because many of the actual students had prior Paxos experience, which helped Paxos considerably, whereas it helped Raft slightly less.  Curiously, the model also predicts scores 6.3 points lower on Raft for people that have already taken the Paxos quiz; although we don’t know why, this does appear to be statistically significant.</p> <p>We also surveyed participants after their quizzes to see which algorithm they felt would be easier to implement or explain; these results are shown in Figure 15. An overwhelming majority of participants reported Raft would be easier to implement and explain (33 of 41 for each question). However, these selfreported feelings may be less reliable than participants’ quiz scores, and participants may have been biased by knowledge of our hypothesisthat Raft is easier to understand.</p> <p>A detailed discussion of the Raft user study is available at [31].</p> <p><img src="/assets/img/image-20211104235428208.2fa83748.png" alt="image20211104235428208"></p> <h3 id="_9-2-correctness"><a href="#_9-2-correctness" class="header-anchor">$</a> 9.2 Correctness</h3> <table><thead><tr><th>Concern</th> <th>Steps taken to mitigate bias</th> <th>Materials for review [28, 31]</th></tr></thead> <tbody><tr><td>Equal lecture quality</td> <td>Same lecturer for both. Paxos lecture based on and improved from existing materials used in several universities. Paxos lecture is 14% longer.</td> <td>videos</td></tr> <tr><td>Equal quiz difficulty</td> <td>Questions grouped in difficulty and paired across exams.</td> <td>quizzes</td></tr> <tr><td>Fair grading</td> <td>Used rubric. Graded in random order, alternating between quizzes.</td> <td>rubric</td></tr></tbody></table> <blockquote><p>Table 1: Concerns of possible bias against Paxos in the study, steps taken to counter each, and additional materials available.</p></blockquote> <p><img src="/assets/img/image-20211106171748298.e6c816be.png" alt="image20211106171748298"></p> <p>We have developed a formal specification and a proof of safety for the consensus mechanism described in Section 5. The formal specification [31] makes the information summarized in Figure 2 completely precise using the TLA+ specification language [17]. It is about 400 lines long and serves as the subject of the proof. It is also useful on its own for anyone implementing Raft. We have mechanically proven the Log Completeness Property using the TLA proof system [7]. However, this proof relies on invariants that have not been mechanically checked (for example, we have not proven the type safety of the specification). Furthermore, we have written an informal proof [31] of the State Machine Safety property which is complete (it relies on the specification alone) and relatively precise (it is about 3500 words long).</p> <h3 id="_9-3-performance"><a href="#_9-3-performance" class="header-anchor">$</a> 9.3 Performance</h3> <p>Raft’s performance is similar to other consensus algorithms such as Paxos. The most important case for performance is when an established leader is replicating new log entries. Raft achieves this using the minimal number of messages (a single roundtrip from the leader to half the cluster). It is also possible to further improve Raft’s performance. For example, it easily supports batching and pipelining requests for higher throughput and lower latency. Various optimizations have been proposed in the literature for other algorithms; many of these could be applied to Raft, but we leave this to future work.</p> <p>We used our Raft implementation to measure the performance of Raft’s leader election algorithm and answer two questions. First, does the election process converge quickly? Second, what is the minimum downtime that can be achieved after leader crashes?</p> <p>To measure leader election, we repeatedly crashed the leader of a cluster of five servers and timed how long it took to detect the crash and elect a new leader (see Figure 16). To generate a worstcase scenario, the servers in each trial had different log lengths, so some candidates were not eligible to become leader. Furthermore, to encourage split votes, our test script triggered a synchronized broadcast of heartbeat RPCs from the leader before terminating its process (this approximates the behavior of the leader replicating a new log entry prior to crashing). The leader was crashed uniformly randomly within its heartbeat interval, which was half of the minimum election timeout for all tests. Thus, the smallest possible downtime was about half of the minimum election timeout.</p> <p>The top graph in Figure 16 shows that a small amount of randomization in the election timeout is enough to avoid split votes in elections. In the absence of randomness, leader election consistently took longer than 10 seconds in our tests due to many split votes. Adding just 5ms of randomness helps significantly, resulting in a median downtime of 287ms. Using more randomness improves worstcase behavior: with 50ms of randomness the worstcase completion time (over 1000 trials) was 513ms.</p> <p>The bottom graph in Figure 16 shows that downtime can be reduced by reducing the election timeout. With an election timeout of 12–24ms, it takes only 35ms on average to elect a leader (the longest trial took 152ms).  However, lowering the timeouts beyond this point violates Raft’s timing requirement: leaders have difficulty broadcasting heartbeats before other servers start new elections.  This can cause unnecessary leader changes and lower overall system availability. We recommend using a conservative election timeout such as 150–300ms; such timeouts are unlikely to cause unnecessary leader changes and will still provide good availability.</p> <h2 id="_10-related-work"><a href="#_10-related-work" class="header-anchor">$</a> 10 Related work</h2> <p>There have been numerous publications related to consensus algorithms, many of which fall into one of the following categories:</p> <ul><li>Lamport’s original description of Paxos [15], and attempts to explain it more clearly [16, 20, 21].</li> <li>Elaborations of Paxos, which fill in missing details  and modify the algorithm to provide a better foundation for implementation [26, 39, 13].</li> <li>Systems that implement consensus algorithms, such  as Chubby [2, 4], ZooKeeper [11, 12], and Spanner [6]. The algorithms for Chubby and Spanner  have not been published in detail, though both claim  to be based on Paxos. ZooKeeper’s algorithm has  been published in more detail, but it is quite different  from Paxos.</li> <li>Performance optimizations that can be applied to  Paxos [18, 19, 3, 25, 1, 27].</li> <li>Oki and Liskov’s Viewstamped Replication (VR), an  alternative approach to consensus developed around  the same time as Paxos. The original description [29]  was intertwined with a protocol for distributed transactions, but the core consensus protocol has been  separated in a recent update [22]. VR uses a leaderbased approach with many similarities to Raft.</li></ul> <p>The greatest difference between Raft and Paxos is Raft’s strong leadership: Raft uses leader election as an essential part of the consensus protocol, and it concentrates as much functionality as possible in the leader. This approach results in a simpler algorithm that is easier to understand. For example, in Paxos, leader election is orthogonal to the basic consensus protocol: it serves only as a performance optimization and is not required for achieving consensus. However, this results in additional mechanism: Paxos includes both a twophase protocol for basic consensus and a separate mechanism for leader election.  In contrast, Raft incorporates leader election directly into the consensus algorithm and uses it as the first of the two phases of consensus. This results in less mechanism than in Paxos.</p> <p>Like Raft, VR and ZooKeeper are leaderbased and therefore share many of Raft’s advantages over Paxos.  However, Raft has less mechanism that VR or ZooKeeper because it minimizes the functionality in nonleaders. For example, log entries in Raft flow in only one direction: outward from the leader in AppendEntries RPCs. In VR log entries flow in both directions (leaders can receive log entries during the election process); this results in additional mechanism and complexity. The published description of ZooKeeper also transfers log entries both to and from the leader, but the implementation is apparently more like Raft [35].</p> <p>Raft has fewer message types than any other algorithm for consensusbased log replication that we are aware of. For example, we counted the message types VR and ZooKeeper use for basic consensus and membership changes (excluding log compaction and client interaction, as these are nearly independent of the algorithms). VR and ZooKeeper each define 10 different message types, while Raft has only 4 message types (two RPC requests and their responses). Raft’s messages are a bit more dense than the other algorithms’, but they are simpler collectively. In addition, VR and ZooKeeper are described in terms of transmitting entire logs during leader changes; additional message types will be required to optimize these mechanisms so that they are practical.</p> <p>Raft’s strong leadership approach simplifies the algorithm, but it precludes some performance optimizations.  For example, Egalitarian Paxos (EPaxos) can achieve higher performance under some conditions with a leaderless approach [27]. EPaxos exploits commutativity in state machine commands. Any server can commit a command with just one round of communication as long as other commands that are proposed concurrently commute with it. However, if commands that are proposed concurrently do not commute with each other, EPaxos requires an additional round of communication. Because any server may commit commands, EPaxos balances load well between servers and is able to achieve lower latency than Raft in WAN settings. However, it adds significant complexity to Paxos.</p> <p>Several different approaches for cluster membership changes have been proposed or implemented in other work, including Lamport’s original proposal [15], VR [22], and SMART [24]. We chose the joint consensus approach for Raft because it leverages the rest of the consensus protocol, so that very little additional mechanism is required for membership changes. Lamport’s α based approach was not an option for Raft because it assumes consensus can be reached without a leader. In comparison to VR and SMART, Raft’s reconfiguration algorithm has the advantage that membership changes can occur without limiting the processing of normal requests; in contrast, VR stops all normal processing during configuration changes, and SMART imposes an α like limit on the number of outstanding requests. Raft’s approach also adds less mechanism than either VR or SMART.</p> <h2 id="_11-conclusion"><a href="#_11-conclusion" class="header-anchor">$</a> 11 Conclusion</h2> <p>Algorithms are often designed with correctness, efficiency, and/or conciseness as the primary goals. Although these are all worthy goals, we believe that understandability is just as important. None of the other goals can be achieved until developers render the algorithm into a practical implementation, which will inevitably deviate from and expand upon the published form. Unless developers have a deep understanding of the algorithm and can create intuitions about it, it will be difficult for them to retain its desirable properties in their implementation.</p> <p>In this paper we addressed the issue of distributed consensus, where a widely accepted but impenetrable algorithm, Paxos, has challenged students and developers for many years. We developed a new algorithm, Raft, which we have shown to be more understandable than Paxos.  We also believe that Raft provides a better foundation for system building. Using understandability as the primary design goal changed the way we approached the design of Raft; as the design progressed we found ourselves reusing a few techniques repeatedly, such as decomposing the problem and simplifying the state space. These techniques not only improved the understandability of Raft but also made it easier to convince ourselves of its correctness.</p> <h2 id="_12-acknowledgments"><a href="#_12-acknowledgments" class="header-anchor">$</a> 12 Acknowledgments</h2> <p>The user study would not have been possible without the support of Ali Ghodsi, David Mazieres, and the students of CS 29491 at Berkeley and CS 240 at Stanford. Scott Klemmer helped us design the user study, and Nelson Ray advised us on statistical analysis. The Paxos slides for the user study borrowed heavily from a slide deck originally created by Lorenzo Alvisi. Special thanks go to David Mazieres and Ezra Hoch for finding subtle bugs in Raft. Many people provided helpful feedback on the paper and user study materials, including Ed Bugnion, Michael Chan, Hugues Evrard,Daniel Giffin, Arjun Gopalan, Jon Howell, Vimalkumar Jeyakumar, Ankita Kejriwal, Aleksandar Kracun, Amit Levy, Joel Martin, Satoshi Matsushita, Oleg Pesok, David Ramos, Robbert van Renesse, Mendel Rosenblum, Nicolas Schiper, Deian Stefan, Andrew Stone, Ryan Stutsman, David Terei, Stephen Yang, Matei Zaharia, 24 anonymous conference reviewers (with duplicates), and especially our shepherd Eddie Kohler. Werner Vogels tweeted a link to an earlier draft, which gave Raft significant exposure. This work was supported by the Gigascale Systems Research Center and the Multiscale Systems Center, two of six research centers funded under the Focus Center Research Program, a Semiconductor Research Corporation program, by STARnet, a Semiconductor Research Corporation program sponsored by MARCO and DARPA, by the National Science Foundation under Grant No. 0963859, and by grants from Facebook, Google, Mellanox, NEC, NetApp, SAP, and Samsung. Diego Ongaro is supported by The Junglee Corporation Stanford Graduate Fellowship.</p> <h2 id="references"><a href="#references" class="header-anchor">$</a> References</h2> <p>[1] BOLOSKY, W. J., BRADSHAW, D., HAAGENS, R. B.,KUSTERS, N. P., AND LI, P. Paxos replicated statemachines as the basis of a highperformance data store.In Proc. NSDI’11, USENIX Conference on NetworkedSystems Design and Implementation (2011), USENIX,pp. 141–154.</p> <p>[2] BURROWS, M. The Chubby lock service for looselycoupled distributed systems. In Proc. OSDI’06, Symposium on Operating Systems Design and Implementation(2006), USENIX, pp. 335–350.</p> <p>[3] CAMARGOS, L. J., SCHMIDT, R. M., AND PEDONE, F.Multicoordinated Paxos. In Proc. PODC’07, ACM Symposium on Principles of Distributed Computing (2007),ACM, pp. 316–317.</p> <p>[4] CHANDRA, T. D., GRIESEMER, R., AND REDSTONE, J.Paxos made live: an engineering perspective. In Proc.PODC’07, ACM Symposium on Principles of DistributedComputing (2007), ACM, pp. 398–407.</p> <p>[5] CHANG, F., DEAN, J., GHEMAWAT, S., HSIEH, W. C.,WALLACH, D. A., BURROWS, M., CHANDRA, T.,FIKES, A., AND GRUBER, R. E. Bigtable: a distributedstorage system for structured data. In Proc. OSDI’06,USENIX Symposium on Operating Systems Design andImplementation (2006), USENIX, pp. 205–218.</p> <p>[6] CORBETT, J. C., DEAN, J., EPSTEIN, M., FIKES, A.,FROST, C., FURMAN, J. J., GHEMAWAT, S., GUBAREV,A., HEISER, C., HOCHSCHILD, P., HSIEH, W., KANTHAK, S., KOGAN, E., LI, H., LLOYD, A., MELNIK,S., MWAURA, D., NAGLE, D., QUINLAN, S., RAO, R.,ROLIG, L., SAITO, Y., SZYMANIAK, M., TAYLOR, C.,WANG, R., AND WOODFORD, D. Spanner: Google’sgloballydistributed database. In Proc. OSDI’12, USENIXConference on Operating Systems Design and Implementation (2012), USENIX, pp. 251–264.</p> <p>[7] COUSINEAU, D., DOLIGEZ, D., LAMPORT, L., MERZ,S., RICKETTS, D., AND VANZETTO, H. TLA+ proofs.In Proc. FM’12, Symposium on Formal Methods (2012),D. Giannakopoulou and D. M ́ery, Eds., vol. 7436 of Lecture Notes in Computer Science, Springer, pp. 147–154.</p> <p>[8] GHEMAWAT, S., GOBIOFF, H., AND LEUNG, S.T. TheGoogle file system. In Proc. SOSP’03, ACM Symposiumon Operating Systems Principles (2003), ACM, pp. 29–43.</p> <p>[9] GRAY, C., AND CHERITON, D. Leases: An efficient faulttolerant mechanism for distributed file cache consistency.In Proceedings of the 12th ACM Ssymposium on OperatingSystems Principles (1989), pp. 202–210.</p> <p>[10] HERLIHY, M. P., AND WING, J. M. Linearizability: acorrectness condition for concurrent objects. ACM Transactions on Programming Languages and Systems 12 (July1990), 463–492.</p> <p>[11] HUNT, P., KONAR, M., JUNQUEIRA, F. P., AND REED,B. ZooKeeper: waitfree coordination for internetscalesystems. In Proc ATC’10, USENIX Annual Technical Conference (2010), USENIX, pp. 145–158.</p> <p>[12] JUNQUEIRA, F. P., REED, B. C., AND SERAFINI, M.Zab: Highperformance broadcast for primarybackup systems. In Proc. DSN’11, IEEE/IFIP Int’l Conf. on Dependable Systems &amp; Networks (2011), IEEE Computer Society,pp. 245–256.</p> <p>[13] KIRSCH, J., AND AMIR, Y. Paxos for system builders.Tech. Rep. CNDS20082, Johns Hopkins University,2008.</p> <p>[14] LAMPORT, L. Time, clocks, and the ordering of events ina distributed system. Commununications of the ACM 21, 7(July 1978), 558–565.</p> <p>[15] LAMPORT, L. The parttime parliament. ACM Transactions on Computer Systems 16, 2 (May 1998), 133–169.</p> <p>[16] LAMPORT, L. Paxos made simple. ACM SIGACT News32, 4 (Dec. 2001), 18–25.</p> <p>[17] LAMPORT, L. Specifying Systems, The TLA+ Languageand Tools for Hardware and Software Engineers. AddisonWesley, 2002.</p> <p>[18] LAMPORT, L. Generalized consensus and Paxos. Tech.Rep. MSRTR200533, Microsoft Research, 2005.</p> <p>[19] LAMPORT, L. Fast paxos. Distributed Computing 19, 2(2006), 79–103.</p> <p>[20] LAMPSON, B. W. How to build a highly available systemusing consensus. In Distributed Algorithms, O. Baboagluand K. Marzullo, Eds. SpringerVerlag, 1996, pp. 1–17.</p> <p>[21] LAMPSON, B. W. The ABCD’s of Paxos. In Proc.PODC’01, ACM Symposium on Principles of DistributedComputing (2001), ACM, pp. 13–13.</p> <p>[22] LISKOV, B., AND COWLING, J. Viewstamped replication revisited. Tech. Rep. MITCSAILTR2012021, MIT,July 2012.</p> <p>[23] LogCabin source code. http://github.com/logcabin/logcabin.</p> <p>[24] LORCH, J. R., ADYA, A., BOLOSKY, W. J., CHAIKEN,R., DOUCEUR, J. R., AND HOWELL, J. The SMARTway to migrate replicated stateful services. In Proc. EuroSys’06, ACM SIGOPS/EuroSys European Conference onComputer Systems (2006), ACM, pp. 103–115.</p> <p>[25] MAO, Y., JUNQUEIRA, F. P., AND MARZULLO, K.Mencius: building efficient replicated state machines forWANs. In Proc. OSDI’08, USENIX Conference onOperating Systems Design and Implementation (2008),USENIX, pp. 369–384.</p> <p>[26] MAZI `ERES, D. Paxos made practical. http://www.scs.stanford.edu/ ̃dm/home/papers/paxos.pdf, Jan. 2007.</p> <p>[27] MORARU, I., ANDERSEN, D. G., AND KAMINSKY, M.There is more consensus in egalitarian parliaments. InProc. SOSP’13, ACM Symposium on Operating SystemPrinciples (2013), ACM.</p> <p>[28] Raft user study. http://ramcloud.stanford.edu/ ̃ongaro/userstudy/.</p> <p>[29] OKI, B. M., AND LISKOV, B. H. Viewstampedreplication: A new primary copy method to supporthighlyavailable distributed systems. In Proc. PODC’88,ACM Symposium on Principles of Distributed Computing(1988), ACM, pp. 8–17.</p> <p>[30] O’NEIL, P., CHENG, E., GAWLICK, D., AND ONEIL, E.The logstructured mergetree (LSMtree). Acta Informatica 33, 4 (1996), 351–385.</p> <p>[31] ONGARO, D. Consensus: Bridging Theory and Practice.PhD thesis, Stanford University, 2014 (work in progress).http://ramcloud.stanford.edu/ ̃ongaro/thesis.pdf.</p> <p>[32] ONGARO, D., AND OUSTERHOUT, J. In search of anunderstandable consensus algorithm. In Proc ATC’14,USENIX Annual Technical Conference (2014), USENIX.</p> <p>[33] OUSTERHOUT, J., AGRAWAL, P., ERICKSON, D.,KOZYRAKIS, C., LEVERICH, J., MAZI `ERES, D., MITRA, S., NARAYANAN, A., ONGARO, D., PARULKAR,G., ROSENBLUM, M., RUMBLE, S. M., STRATMANN,E., AND STUTSMAN, R. The case for RAMCloud. Communications of the ACM 54 (July 2011), 121–130.</p> <p>[34] Raft consensus algorithm website.http://raftconsensus.github.io.</p> <p>[35] REED, B. Personal communications, May 17, 2013.</p> <p>[36] ROSENBLUM, M., AND OUSTERHOUT, J. K. The designand implementation of a logstructured file system. ACMTrans. Comput. Syst. 10 (February 1992), 26–52.</p> <p>[37] SCHNEIDER, F. B. Implementing faulttolerant servicesusing the state machine approach: a tutorial. ACM Computing Surveys 22, 4 (Dec. 1990), 299–319.</p> <p>[38] SHVACHKO, K., KUANG, H., RADIA, S., ANDCHANSLER, R. The Hadoop distributed file system.In Proc. MSST’10, Symposium on Mass Storage Systems and Technologies (2010), IEEE Computer Society,pp. 1–10.</p> <p>[39] VAN RENESSE, R. Paxos made moderately complex.Tech. rep., Cornell University, 2012.</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">11/7/2021, 6:56:37 AM</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.a2246195.js" defer></script><script src="/assets/js/2.a92520c9.js" defer></script><script src="/assets/js/3.cd488c94.js" defer></script>
  </body>
</html>
